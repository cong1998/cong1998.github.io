<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>ssr订阅分享</title>
      <link href="/2020/05/02/ssr-ding-yue-fen-xiang/"/>
      <url>/2020/05/02/ssr-ding-yue-fen-xiang/</url>
      
        <content type="html"><![CDATA[<h1 id="ssr订阅分享"><a href="#ssr订阅分享" class="headerlink" title="ssr订阅分享"></a>ssr订阅分享</h1><p><strong>ZCSSR : <a href="https://zc17.xyz/auth/register?code=NoUD" target="_blank" rel="noopener">https://zc17.xyz/auth/register?code=NoUD</a></strong></p><p><strong>彼岸花：</strong><a href="https://bianhuaho.com/auth/register?code=7zqF" target="_blank" rel="noopener">https://bianhuaho.com/auth/register?code=7zqF</a></p><p><strong>T云速：</strong><a href="https://asfsdgfdfhgdfhdfsdfsd.xyz/auth/register?code=xgD4" target="_blank" rel="noopener">https://asfsdgfdfhgdfhdfsdfsd.xyz/auth/register?code=xgD4</a></p><p><strong>科学云：</strong><a href="https://subsice.site/auth/register?code=ZmiN" target="_blank" rel="noopener">https://subsice.site/auth/register?code=ZmiN</a></p><p><strong>优云666：</strong><a href="https://youyun666.com/auth/register?code=I1HE" target="_blank" rel="noopener">https://youyun666.com/auth/register?code=I1HE</a></p><p><strong>速鹰666：</strong><a href="https://youyun666.com/auth/register?code=I1HE" target="_blank" rel="noopener">https://youyun666.com/auth/register?code=I1HE</a></p><p><strong>lncn：</strong><a href="https://lncn.org/" target="_blank" rel="noopener">https://lncn.org/</a></p>]]></content>
      
      
      <categories>
          
          <category> ssr </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 机场 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ssr - window 教程</title>
      <link href="/2020/05/02/chang-jian-ssr-window-jiao-cheng/"/>
      <url>/2020/05/02/chang-jian-ssr-window-jiao-cheng/</url>
      
        <content type="html"><![CDATA[<h1 id="常见-ssr-window-教程"><a href="#常见-ssr-window-教程" class="headerlink" title="常见 ssr  -  window 教程"></a>常见 ssr  -  window 教程</h1><h2 id="1-下载及说明"><a href="#1-下载及说明" class="headerlink" title="1.下载及说明"></a>1.下载及说明</h2><p><a href="https://github.com/shadowsocksr-backup/shadowsocksr-csharp/releases" target="_blank" rel="noopener">下载</a></p><p><img src="/images/ssr/assets/folder.png" alt=""></p><p><code>注：演示版本为4.7.0</code></p><p>目录说明：</p><p>​     templates : shadowsocksR的页面模板文件（页面，无特殊情况请勿修改）</p><p>​     chn_ip.txt ：记录中国ip范围，用于那些该放行</p><p>​     2.0.exe  :  xp系统请选择</p><p>​     4.0.exe  :  如果你的电脑上已经安装了NET Framework 4.0,请选择</p><p>​     .sig  ：文件为MD5校验文件</p><p>​     user.rule : 放行规则文件</p><h2 id="2-功能、设置说明"><a href="#2-功能、设置说明" class="headerlink" title="2.功能、设置说明"></a>2.功能、设置说明</h2><p>右击小飞机，你能看到 SSR 所有的功能选项，以下是各项功能及设置的介绍。</p><h3 id="系统代理模式"><a href="#系统代理模式" class="headerlink" title="系统代理模式"></a>系统代理模式</h3><p>系统代理模式有四种模式可以选择：</p><p><strong>直连模式</strong><br>会关闭系统HTTP代理，你的所有HTTP上网流量都不会通过 SSR 代理，在此模式下你只能使用Socks5代理方式连接 SSR 代理。</p><ul><li><p><strong>PAC模式</strong><br>会修改系统IE代理，使用PAC文件控制代理。PAC文件包含了规则列表，可以控制哪些流量走 SSR，哪些不走（例如国内流量直连，国外走代理），做到智能代理。<strong>但是实际上此功能已经可以被“代理规则”设置完全代替（除非你一定要用gfwlist），因此一般不用这一模式。</strong><br>PAC文件为 SSR 根目录下的<code>pac.txt</code>。</p></li><li><p><strong>全局模式</strong><br>会开启系统HTTP代理，你的所有HTTP上网流量将会通过 SSR 代理。<br>注意：仅能代理HTTP流量，即浏览网页的流量——例如浏览器浏览网页，或者某些应用程序的应用内网页（比如QQ的群文件、群公告这些就是），或者某些比较奇葩的使用HTTP方式进行通信的程序（比如Steam版的影之诗）。</p></li><li><p><strong>保持当前状态不修改</strong><br>顾名思义，不会对你目前的系统HTTP代理状态进行任何的修改。</p></li></ul><p>当你退出 SSR 后，系统HTTP代理会自动被恢复至原有状态；开启 SSR 后，同样的，系统HTTP代理会被设置成你所设定的系统代理模式状态。</p><h3 id="PAC"><a href="#PAC" class="headerlink" title="PAC"></a>PAC</h3><p>此菜单中的选项均为对 SSR 的PAC文件进行操作的选项，如果你不使用“PAC模式”代理，那么这一节你可以直接跳过。</p><p>不过实际上也没什么好讲的，每个选项会执行什么操作、有什么效果，都在菜单中写的清清楚楚。</p><p><img src="/images/ssr/assets/common.jpg" alt=""></p><h3 id="代理规则"><a href="#代理规则" class="headerlink" title="代理规则"></a>代理规则</h3><p>代理规则指的是，对于所有通过系统HTTP代理或者SOCKS5代理被发送至 SSR 的流量，按照你设置的规则进行代理，即智能代理。</p><p>实际上这个设置项也没有什么可以说明的内容，每个选项也写的很清楚。这里稍微解释下某些名词及选项：</p><ul><li><strong>绕过xxx</strong><br>顾名思义，绕过就是不走代理，例如选择项中的“绕过局域网“就是当你浏览局域网网页的时候不会走 SSR 代理（最常见的例如学校、公司的内部网网页），”绕过大陆“就是所有国内大陆的流量都不会通过 SSR 代理。</li><li><strong>绕过非大陆</strong><br>带有这个的一项实际上是给从国外翻回来的人用的，我们这些翻出去的并用不到。</li><li><strong>用户自定义</strong><br>萌新可以直接无视这一项。自定义文件为 SSR 根目录下的<code>user-rule.txt</code>，你可以在这一文件中自己定义代理规则，格式详见：<a href="https://adblockplus.org/en/filter-cheatsheet" target="_blank" rel="noopener">https://adblockplus.org/en/filter-cheatsheet</a></li><li><strong>全局</strong><br>顾名思义，所有被发送至 SSR 的流量都会走代理。</li></ul><p>日常使用我推荐使用“绕过局域网和大陆”的选项</p><h3 id="服务器"><a href="#服务器" class="headerlink" title="服务器"></a>服务器</h3><p>在这里你可以切换你已有的服务器配置，在你第一次使用的时候别忘了先切换至你自己添加的服务器配置。</p><ul><li><p><strong>编辑服务器</strong><br>直接双击小飞机也可以打开编辑窗口。</p></li><li><p><strong>从文件导入服务器</strong><br>可以导入 SSR 服务商提供的服务器配置文件。</p></li><li><p><strong>服务器连接统计</strong><br>直接鼠标中键单机小飞机也可以打开这一窗口，会显示你目前 SSR 的所有服务器的统计信息。</p><p><img src="/images/ssr/assets/common(1).png" alt=""></p><p>在这一界面，双击某个条目的服务器可以直接切换至该服务器；<br>单击某一条目的“连接”可以断开当前条目的所有连接；<br>双击某一条目的“开关”可以指定你在设置服务器负载均衡时是否使用这一服务器，而双击某一个“组”(Group)可以批量开关这一组；<br>双击某一条目其他的列可以清零这一统计信息。</p></li></ul><h3 id="服务器订阅"><a href="#服务器订阅" class="headerlink" title="服务器订阅"></a>服务器订阅</h3><p>此处可以设置服务器订阅，初次使用请先删掉自带的服务器订阅（已经失效）。</p><p>如果你没有从 SSR 提供商处获得 SSR 服务器订阅地址，那么可以直接跳过本节。</p><ul><li><strong>SSR 服务器订阅设置</strong><br>点击“ADD”，然后在右侧填入你的 SSR 服务器订阅地址，即可添加一条服务器订阅，然后直接点击确定即可。如果你勾选了左下角的“自动更新”，在每次 SSR 启动的时候都会自动更新订阅，一般情况下无需选择。</li><li><strong>更新服务器订阅</strong><br>将会从已经设置的订阅地址中获取配置信息自动添加/更新至服务器配置中，<strong>并且此操作会通过你当前的 SSR 代理进行！</strong>如果你目前的 SSR 代理不是可用的代理，那么将会更新失败！<strong>因此建议选择“更新服务器订阅（不通过代理）”。</strong>一般只有 SSR 服务器订阅地址不能在墙内访问而你有可以使用的 SSR 代理配置的时候才需要使用 SSR 代理更新订阅。</li></ul><h3 id="服务器负载均衡"><a href="#服务器负载均衡" class="headerlink" title="服务器负载均衡"></a>服务器负载均衡</h3><p>这是个基本不会用到的功能。选中以后，在每次有流量通过 SSR 代理时，会自动在没有被“关掉”的代理中选择一个来使用。</p><p>如果想只在某一组服务器中切换，或者依据一定的条件来切换服务器，请右击小飞机-选项设置，然后看“负载均衡”的设置。</p><h3 id="选项设置"><a href="#选项设置" class="headerlink" title="选项设置"></a>选项设置</h3><ul><li><strong>二级（前置）代理</strong><br>使用代理来连接代理，就像盗梦空间那样。没有特殊需求就不用管这一项。</li><li><strong>负载均衡</strong><br>没什么好说的，每个设置有什么用都写的简单明了。</li><li><strong>本地代理</strong><br>这是个很重要的设置项。<br>本地代理实际上就是在本机(127.0.0.1)开启一个SOCKS5代理端口，端口为“本地端口”设置项中的端口号。<br>如果勾选了“允许来自局域网的连接”，则与你在同一局域网的其他设备一可以通过这一SOCKS5代理来连接，服务器地址为你的局域网IP地址。<br>用户名和密码选填，如果你设置了，那么当你使用SOCKS5代理的时候就需要这一用户名密码了。</li><li><strong>右下角的设置</strong><br>没啥好说的（。</li></ul><h3 id="端口设置"><a href="#端口设置" class="headerlink" title="端口设置"></a>端口设置</h3><p>可以设置端口转发以及对于不同的服务器配置开启不同的本地代理SOCKS5端口等等。萌新直接不用管。</p><h3 id="二维码扫描"><a href="#二维码扫描" class="headerlink" title="二维码扫描"></a>二维码扫描</h3><p>可以扫描屏幕上的 SSR 配置信息二维码并导入服务器配置中。二维码通常由你的 SSR 供应商提供。</p><h3 id="剪贴板批量导入ssr-链接"><a href="#剪贴板批量导入ssr-链接" class="headerlink" title="剪贴板批量导入ssr://链接"></a>剪贴板批量导入ssr://链接</h3><p>没啥好讲的，如果你的 SSR 供应商有提供批量 SSR 服务器配置链接，你就可以复制之后通过这里导入。</p><h3 id="帮助"><a href="#帮助" class="headerlink" title="帮助"></a>帮助</h3><p>由于众所周知的原因，破娃酱已经删除了 Github 上的所有 SSR 项目，并且停止了对 SSR 的开发及维护，因此这里的什么“检查更新”啊“打开 Wiki 文档”啊都是已经没用了的选项。</p><p><a href="https://github.com/shadowsocksr-backup/shadowsocks-rss/wiki" target="_blank" rel="noopener">https://github.com/shadowsocksr-backup/shadowsocks-rss/wiki</a><br>以上是 Wiki 文档备份</p><ul><li><strong>显示日志</strong><br>显示 SSR 通信日志。</li><li><strong>自定义生成二维码</strong><br>这就是一个生成二维码的小工具而已。</li><li><strong>设置客户端密码</strong><br>为你的 SSR 客户端设置密码保护。</li></ul><h2 id="3-常见问题"><a href="#3-常见问题" class="headerlink" title="3.常见问题"></a>3.常见问题</h2><h3 id="无法更新-PAC"><a href="#无法更新-PAC" class="headerlink" title="无法更新 PAC"></a>无法更新 PAC</h3><p>因在线更新的 PAC 所在的项目均已被删除，因此酸酸乳自带的 PAC 更新功能已无法使用，你可以换用 SSRR 客户端</p><h3 id="使用了代理之后查询自己的-IP-发现还是国内的"><a href="#使用了代理之后查询自己的-IP-发现还是国内的" class="headerlink" title="使用了代理之后查询自己的 IP 发现还是国内的"></a>使用了代理之后查询自己的 IP 发现还是国内的</h3><p>你大概是直接去百度“IP”或者使用了国内的查询IP的服务，而且你的 SSR 代理模式设置的是“绕过大陆”。</p><p>请将代理模式改为“全局”后再试，或者访问位于国外的 IP 查询服务网站例如 <a href="https://ip.sb/" target="_blank" rel="noopener">https://ip.sb</a></p><h3 id="打开-SSR-提示xxxx端口已被占用"><a href="#打开-SSR-提示xxxx端口已被占用" class="headerlink" title="打开 SSR 提示xxxx端口已被占用"></a>打开 SSR 提示xxxx端口已被占用</h3><p>你的 SSR 的 SOCKS5 端口被系统中的其他程序占用了，去更改 SSR选项设置 中的本地端口吧。推荐改为 1025~65535 之间的端口（1024之前的端口有系统保留端口，防止误占用）。</p><h3 id="无法更新-SSR-服务器订阅"><a href="#无法更新-SSR-服务器订阅" class="headerlink" title="无法更新 SSR 服务器订阅"></a>无法更新 SSR 服务器订阅</h3><p><strong>在关闭代理的情况下</strong>，直接把你的订阅网址扔到浏览器里，看看是否能正常访问，正常情况下会直接显示一串毫无规律的英文数字或者弹出一个文件下载框。</p><ul><li><strong>能√</strong><br>解决方法：选择“更新 SSR 服务器订阅<strong>（不通过代理）</strong>”<br>问题分析：你可能是在还没有添加有效服务器配置的时候直接选择了“更新 SSR 服务器订阅”。<br>如果不选含有“（不通过代理）”的那一项，那么 SSR <strong>默认将会通过代理来更新订阅</strong>，然而你并没有有效的服务器配置，因此自然就无法更新了。</li><li><strong>不能×</strong><br>那么检查一下你是不是手打打错了或者复制少了一部分网址……<br>如果你很确信订阅地址没有错，如果你有可用的代理配置的话，就尝试通过代理更新订阅。<br>如果还是不行，请找到你的 SSR 代理商询问原因。</li></ul><h3 id="正确添加了配置，但无法正常使用代理上网"><a href="#正确添加了配置，但无法正常使用代理上网" class="headerlink" title="正确添加了配置，但无法正常使用代理上网"></a>正确添加了配置，但无法正常使用代理上网</h3><p>逐步排查问题：</p><ol><li><p><strong>计算机中是否有安装程序所需依赖</strong><br>例如 .NET 以及 VC++运行环境 之类的，特别是 VC++ 运行环境，当你没安装的时候可以打开程序，但是你看日志会有报错，无法使用各种加密</p></li><li><p>你可能根本就连不上你的ss代理服务器</p><p>打开命令提示符（Win+R打开“运行”，输入</p><pre><code>cmd</code></pre><p>然后回车Enter，接着输入</p><pre><code>ping 你的SSR服务器地址</code></pre><p>然后回车，查看是否能Ping通，否则说明你目前的网络情况根本无法连接代理。<br><em>New: 目前 GFW 开始使用 TCP 阻断的方式</em></p></li><li><p><strong>你的SSR配置可能不正确</strong><br>如果你是手动填写的配置而不是通过SSR提供商的一键配置来添加，那可能会出现这种情况，请检查一下你的配置是否正确。</p></li><li><p><strong>SSR的系统代理模式和代理规则是否正确</strong><br>通常来讲推荐萌新的设置是，系统代理模式选择“全局模式”，代理规则选择“绕过局域网和大陆”。</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> ssr </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ssr-window </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>单例设计模式</title>
      <link href="/2020/04/30/dan-li-mo-shi/"/>
      <url>/2020/04/30/dan-li-mo-shi/</url>
      
        <content type="html"><![CDATA[<h1 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h1><p>单例模式（Singleton Pattern）是 Java 中最简单的设计模式之一。这种类型的设计模式属于创建型模式，它提供了一种创建对象的最佳方式。</p><p>这种模式涉及到一个单一的类，该类负责创建自己的对象，同时确保只有单个对象被创建。这个类提供了一种访问其唯一的对象的方式，可以直接访问，不需要实例化该类的对象。</p><p><strong>注意：</strong></p><p>1、单例类只能有一个实例。</p><p>2、单例类必须自己创建自己的唯一实例。</p><p>3、单例类必须给所有其他对象提供这一实例。</p><p><strong>优点：</strong></p><p>1、在内存里只有一个实例，减少了内存的开销，尤其是频繁的创建和销毁实例</p><p>2、避免对资源的多重占用（比如写文件操作）。</p><p><strong>缺点：</strong></p><p> 1、没有接口，不能继承，与单一职责原则冲突，一个类应该只关心内部逻辑，而不关心外面怎么样来实例化。</p><hr><h2 id="饿汉式（静态常量-静态代码块）"><a href="#饿汉式（静态常量-静态代码块）" class="headerlink" title="饿汉式（静态常量/静态代码块）"></a>饿汉式（静态常量/静态代码块）</h2><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Singleton</span> <span class="token punctuation">{</span>   <span class="token comment" spellcheck="true">//创建 Single 的一个对象</span>   <span class="token keyword">private</span> <span class="token keyword">static</span> Singleton instance <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Singleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">//让构造函数为 private，这样该类就不会被实例化</span>   <span class="token keyword">private</span> <span class="token function">Singleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span>   <span class="token comment" spellcheck="true">//获取唯一可用的对象</span>   <span class="token keyword">public</span> <span class="token keyword">static</span> Singleton <span class="token function">getInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>      <span class="token keyword">return</span> instance<span class="token punctuation">;</span>   <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p><strong>优点：</strong>比较简单，在类装载时完成实例化，避免了线程同步问题</p><p><strong>缺点：</strong>在类装载时完成初始化，没有达到 Lazy Loading 的效果，可能造成内存浪费</p><hr><h2 id="懒汉式（同步方法-不推荐）"><a href="#懒汉式（同步方法-不推荐）" class="headerlink" title="懒汉式（同步方法/不推荐）"></a>懒汉式（同步方法/不推荐）</h2><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Singleton</span> <span class="token punctuation">{</span>      <span class="token keyword">private</span> <span class="token keyword">static</span> Singleton instance<span class="token punctuation">;</span>      <span class="token keyword">private</span> <span class="token function">Singleton</span> <span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span>      <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">synchronized</span> Singleton <span class="token function">getInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>         <span class="token keyword">if</span> <span class="token punctuation">(</span>instance <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>            instance <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Singleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>         <span class="token punctuation">}</span>         <span class="token keyword">return</span> instance<span class="token punctuation">;</span>      <span class="token punctuation">}</span>  <span class="token punctuation">}</span></code></pre><p><strong>优点：</strong>解决了传统懒汉式的线程问题</p><p><strong>缺点：</strong>同步方法效率低下</p><hr><h2 id="双重检测（推荐）"><a href="#双重检测（推荐）" class="headerlink" title="双重检测（推荐）"></a>双重检测（推荐）</h2><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Singleton</span> <span class="token punctuation">{</span>      <span class="token keyword">private</span> <span class="token keyword">volatile</span> <span class="token keyword">static</span> Singleton singleton<span class="token punctuation">;</span>      <span class="token keyword">private</span> <span class="token function">Singleton</span> <span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span>      <span class="token keyword">public</span> <span class="token keyword">static</span> Singleton <span class="token function">getSingleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>         <span class="token keyword">if</span> <span class="token punctuation">(</span>singleton <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>             <span class="token keyword">synchronized</span> <span class="token punctuation">(</span>Singleton<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                 <span class="token keyword">if</span> <span class="token punctuation">(</span>singleton <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>                     singleton <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Singleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                 <span class="token punctuation">}</span>             <span class="token punctuation">}</span>         <span class="token punctuation">}</span>         <span class="token keyword">return</span> singleton<span class="token punctuation">;</span>      <span class="token punctuation">}</span>  <span class="token punctuation">}</span></code></pre><p><strong>优点：</strong>线程安全，延迟加载，效率较高</p><hr><h2 id="静态内部类（推荐）"><a href="#静态内部类（推荐）" class="headerlink" title="静态内部类（推荐）"></a>静态内部类（推荐）</h2><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Singleton</span> <span class="token punctuation">{</span>      <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">SingletonHolder</span> <span class="token punctuation">{</span>         <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> Singleton INSTANCE <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Singleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token punctuation">}</span>      <span class="token keyword">private</span> <span class="token function">Singleton</span> <span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span>      <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">final</span> Singleton <span class="token function">getInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>         <span class="token keyword">return</span> SingletonHolder<span class="token punctuation">.</span>INSTANCE<span class="token punctuation">;</span>      <span class="token punctuation">}</span>  <span class="token punctuation">}</span></code></pre><p><strong>优点：</strong>利用classloader机制来保证初始化instance时只有一个线程，Singleton类被装载时，SingletonHolder类没有被主动使用，即 Lazy Loading</p><hr><h2 id="枚举（推荐）"><a href="#枚举（推荐）" class="headerlink" title="枚举（推荐）"></a>枚举（推荐）</h2><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">enum</span> Singleton <span class="token punctuation">{</span>    INSTANCE<span class="token punctuation">;</span>      <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">whateverMethod</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token punctuation">}</span>  <span class="token punctuation">}</span></code></pre><p>优点：线程安全，防止反序列化</p>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 单例 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>设计模式7大原则</title>
      <link href="/2020/04/30/she-ji-mo-shi-7-da-yuan-ze/"/>
      <url>/2020/04/30/she-ji-mo-shi-7-da-yuan-ze/</url>
      
        <content type="html"><![CDATA[<h1 id="设计模式7大原则"><a href="#设计模式7大原则" class="headerlink" title="设计模式7大原则"></a>设计模式7大原则</h1><h2 id="单一指责"><a href="#单一指责" class="headerlink" title="单一指责"></a>单一指责</h2><p><code>对类来说，既一个类应该只负责一项指责。如类A负责两个不同指责：指责1，指责2；当指责1需求变更而改变A时，可能造成指责2执行错误，所以需要将类A的粒度分解为A1，A2</code></p><p><code>软件设计应遵守单一职责原则，将不同的职责封装到不同的类或模块中</code></p><h2 id="开闭原则"><a href="#开闭原则" class="headerlink" title="开闭原则"></a>开闭原则</h2><p><code>开闭原则的意思是：**对扩展开放，对修改关闭**。在程序需要进行拓展的时候，不能去修改原有的代码，实现一个热插拔的效果。简言之，是为了使程序的扩展性好，易于维护和升级。想要达到这样的效果，我们需要使用接口和抽象类，后面的具体设计中我们会提到这点。</code></p><ul><li><p><code>通过扩展已有软件系统，可以提供新的行为，以满足对软件的新的需求，使变化中的软件有一定的适应性和灵活性。</code></p></li><li><p><code>已有软件模块，特别是最重要的抽象层模块不能再修改，这使变化中的软件系统有一定的稳定性和延续性` `实现开闭原则的关键在于 **分离不变和变化的部分，并对变化的部分进行合理的高层抽象，并让不变的部分依赖该高层抽象**，这样就能在不同的实现间切换，或者扩展新的实现。很多设计模式都体现了这一点，比如策略模式将算法抽象出来，模板方法将不变的算法骨架与易变的需要自定义的步骤隔离，装饰者模式将不变的核心功能对象和易变的增强功能隔离等等</code></p></li></ul><h2 id="里氏代换原则"><a href="#里氏代换原则" class="headerlink" title="里氏代换原则"></a>里氏代换原则</h2><p><code>里氏代换原则是面向对象设计的基本原则之一。 里氏代换原则中说，任何基类可以出现的地方，子类一定可以出现。LSP 是继承复用的基石，只有当派生类可以替换掉基类，且软件单位的功能不受到影响时，基类才能真正被复用，而派生类也能够在基类的基础上增加新的行为。里氏代换原则是对开闭原则的补充。实现开闭原则的关键步骤就是抽象化，而基类与子类的继承关系就是抽象化的具体实现，所以里氏代换原则是对实现抽象化的具体步骤的规范。</code></p><h2 id="依赖倒转原则"><a href="#依赖倒转原则" class="headerlink" title="依赖倒转原则"></a>依赖倒转原则</h2><p><code>这个原则是开闭原则的基础，具体内容：针对接口编程，依赖于抽象而不依赖于具体。</code></p><h2 id="接口隔离原则"><a href="#接口隔离原则" class="headerlink" title="接口隔离原则"></a>接口隔离原则</h2><p><code>这个原则的意思是：使用多个隔离的接口，比使用单个接口要好。它还有另外一个意思是：降低类之间的耦合度。由此可见，其实设计模式就是从大型软件架构出发、便于升级和维护的软件设计思想，它强调降低依赖，降低耦合。</code></p><h2 id="迪米特法则（最少知道原则）"><a href="#迪米特法则（最少知道原则）" class="headerlink" title="迪米特法则（最少知道原则）"></a>迪米特法则（最少知道原则）</h2><p><code>最少知道原则是指：一个实体应当尽量少地与其他实体之间发生相互作用，使得系统功能模块相对独立。</code></p><p><code>原则：只与直接的朋友进行通信</code></p><blockquote><p>直接的朋友：每个对象都会与其他对象有耦合关系，只要两个对象之间有耦合关系，我们就说这两个对象之间是朋友关系。耦合的方式很多，依赖，关联，组合，聚合等。其中，我们称出现<strong>成员变量，方法参数，方法返回值</strong>中的类为直接的朋友，而且现在<strong>局部变量中的类不是直接的朋友</strong>。也就是说，陌生的类最好不要以局部变量的形式出现在类的内部</p></blockquote><p>​     </p><h2 id="合称复用原则"><a href="#合称复用原则" class="headerlink" title="合称复用原则"></a>合称复用原则</h2><p><code>合成复用原则是指：尽量使用合成/聚合的方式，而不是使用继承。</code></p>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式七大原则 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>docker-simple</title>
      <link href="/2020/04/30/docker/"/>
      <url>/2020/04/30/docker/</url>
      
        <content type="html"><![CDATA[<h1 id="一、环境配置"><a href="#一、环境配置" class="headerlink" title="一、环境配置"></a>一、环境配置</h1><pre class=" language-shell"><code class="language-shell">1、检查内核版本，必须是3.10及以上 uname ‐r 2、安装docker yum install docker3、输入y确认安装4、启动docker [root@localhost ~]# systemctl start docker               [root@localhost ~]# docker ‐v                Docker version 1.12.6, build 3e8e77d/1.12.65、开机启动docker [root@localhost ~]# systemctl enable docker                  Created symlink from /etc/systemd/system/multi‐user.target.wants/docker.service to /usr/lib/systemd/system/docker.service. 6、停止docker systemctl stop docker</code></pre><p><img src="/images/docker/aliyun-docker.png" alt=""></p><h2 id="Docker常用命令-amp-操作"><a href="#Docker常用命令-amp-操作" class="headerlink" title="Docker常用命令&amp;操作"></a>Docker常用命令&amp;操作</h2><p><img src="/images/docker/simple.png" alt=""></p><h2 id="操作指令"><a href="#操作指令" class="headerlink" title="操作指令"></a>操作指令</h2><pre class=" language-shell"><code class="language-shell">1.搜索镜像 docker search tomcat 2.拉取镜像 docker pull tomcat 3.根据镜像启动容器 docker run --name mytomcat -d tomcat:latest 4.查看运行中的容器 docker ps 5.停止运行中的容器 docker stop 容器id 6.查看所有的容器 docker ps -a 7.启动容器 docker start 容器id 8.删除一个容器 docker rm 容器id 9.启动一个做了端口映射的tomcat docker run -d -p 8888:8080 tomcat 10.查看容器的日志 docker logs 容器id/容器名字 11.容器挂载 docker run --name mysql -v /conf/mysql:/etc/mysql mysql 12.进入容器 docker exec -it 容器id bash</code></pre><h2 id="迁移与备份"><a href="#迁移与备份" class="headerlink" title="迁移与备份"></a>迁移与备份</h2><pre class=" language-shell"><code class="language-shell">1.容器保存为镜像docker commit 现有容器id/容器名字 保存的镜像名字2.镜像备份docker save -o 保存的名字.tar 要保存的镜像3.镜像恢复与迁移docker load -i 要恢复的文件.tar</code></pre>]]></content>
      
      
      <categories>
          
          <category> docker </category>
          
      </categories>
      
      
        <tags>
            
            <tag> init </tag>
            
            <tag> simple syntax </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2020/04/28/hello-world/"/>
      <url>/2020/04/28/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><pre class=" language-bash"><code class="language-bash">$ hexo new <span class="token string">"My New Post"</span></code></pre><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><pre class=" language-bash"><code class="language-bash">$ hexo server</code></pre><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><pre class=" language-bash"><code class="language-bash">$ hexo generate</code></pre><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><pre class=" language-bash"><code class="language-bash">$ hexo deploy</code></pre><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> init </tag>
            
            <tag> simple syntax </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
