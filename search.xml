<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>单例设计模式</title>
      <link href="/2020/04/30/dan-li-mo-shi/"/>
      <url>/2020/04/30/dan-li-mo-shi/</url>
      
        <content type="html"><![CDATA[<h1 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h1><p>单例模式（Singleton Pattern）是 Java 中最简单的设计模式之一。这种类型的设计模式属于创建型模式，它提供了一种创建对象的最佳方式。</p><p>这种模式涉及到一个单一的类，该类负责创建自己的对象，同时确保只有单个对象被创建。这个类提供了一种访问其唯一的对象的方式，可以直接访问，不需要实例化该类的对象。</p><p><strong>注意：</strong></p><p>1、单例类只能有一个实例。</p><p>2、单例类必须自己创建自己的唯一实例。</p><p>3、单例类必须给所有其他对象提供这一实例。</p><p><strong>优点：</strong></p><p>1、在内存里只有一个实例，减少了内存的开销，尤其是频繁的创建和销毁实例</p><p>2、避免对资源的多重占用（比如写文件操作）。</p><p><strong>缺点：</strong></p><p> 1、没有接口，不能继承，与单一职责原则冲突，一个类应该只关心内部逻辑，而不关心外面怎么样来实例化。</p><hr><h2 id="饿汉式（静态常量-静态代码块）"><a href="#饿汉式（静态常量-静态代码块）" class="headerlink" title="饿汉式（静态常量/静态代码块）"></a>饿汉式（静态常量/静态代码块）</h2><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Singleton</span> <span class="token punctuation">{</span>   <span class="token comment" spellcheck="true">//创建 Single 的一个对象</span>   <span class="token keyword">private</span> <span class="token keyword">static</span> Singleton instance <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Singleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">//让构造函数为 private，这样该类就不会被实例化</span>   <span class="token keyword">private</span> <span class="token function">Singleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span>   <span class="token comment" spellcheck="true">//获取唯一可用的对象</span>   <span class="token keyword">public</span> <span class="token keyword">static</span> Singleton <span class="token function">getInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>      <span class="token keyword">return</span> instance<span class="token punctuation">;</span>   <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p><strong>优点：</strong>比较简单，在类装载时完成实例化，避免了线程同步问题</p><p><strong>缺点：</strong>在类装载时完成初始化，没有达到 Lazy Loading 的效果，可能造成内存浪费</p><hr><h2 id="懒汉式（同步方法-不推荐）"><a href="#懒汉式（同步方法-不推荐）" class="headerlink" title="懒汉式（同步方法/不推荐）"></a>懒汉式（同步方法/不推荐）</h2><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Singleton</span> <span class="token punctuation">{</span>      <span class="token keyword">private</span> <span class="token keyword">static</span> Singleton instance<span class="token punctuation">;</span>      <span class="token keyword">private</span> <span class="token function">Singleton</span> <span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span>      <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">synchronized</span> Singleton <span class="token function">getInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>         <span class="token keyword">if</span> <span class="token punctuation">(</span>instance <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>            instance <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Singleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>         <span class="token punctuation">}</span>         <span class="token keyword">return</span> instance<span class="token punctuation">;</span>      <span class="token punctuation">}</span>  <span class="token punctuation">}</span></code></pre><p><strong>优点：</strong>解决了传统懒汉式的线程问题</p><p><strong>缺点：</strong>同步方法效率低下</p><hr><h2 id="双重检测（推荐）"><a href="#双重检测（推荐）" class="headerlink" title="双重检测（推荐）"></a>双重检测（推荐）</h2><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Singleton</span> <span class="token punctuation">{</span>      <span class="token keyword">private</span> <span class="token keyword">volatile</span> <span class="token keyword">static</span> Singleton singleton<span class="token punctuation">;</span>      <span class="token keyword">private</span> <span class="token function">Singleton</span> <span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span>      <span class="token keyword">public</span> <span class="token keyword">static</span> Singleton <span class="token function">getSingleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>         <span class="token keyword">if</span> <span class="token punctuation">(</span>singleton <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>             <span class="token keyword">synchronized</span> <span class="token punctuation">(</span>Singleton<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                 <span class="token keyword">if</span> <span class="token punctuation">(</span>singleton <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>                     singleton <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Singleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                 <span class="token punctuation">}</span>             <span class="token punctuation">}</span>         <span class="token punctuation">}</span>         <span class="token keyword">return</span> singleton<span class="token punctuation">;</span>      <span class="token punctuation">}</span>  <span class="token punctuation">}</span></code></pre><p><strong>优点：</strong>线程安全，延迟加载，效率较高</p><hr><h2 id="静态内部类（推荐）"><a href="#静态内部类（推荐）" class="headerlink" title="静态内部类（推荐）"></a>静态内部类（推荐）</h2><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Singleton</span> <span class="token punctuation">{</span>      <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">SingletonHolder</span> <span class="token punctuation">{</span>         <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> Singleton INSTANCE <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Singleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token punctuation">}</span>      <span class="token keyword">private</span> <span class="token function">Singleton</span> <span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span>      <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">final</span> Singleton <span class="token function">getInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>         <span class="token keyword">return</span> SingletonHolder<span class="token punctuation">.</span>INSTANCE<span class="token punctuation">;</span>      <span class="token punctuation">}</span>  <span class="token punctuation">}</span></code></pre><p><strong>优点：</strong>利用classloader机制来保证初始化instance时只有一个线程，Singleton类被装载时，SingletonHolder类没有被主动使用，即 Lazy Loading</p><hr><h2 id="枚举（推荐）"><a href="#枚举（推荐）" class="headerlink" title="枚举（推荐）"></a>枚举（推荐）</h2><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">enum</span> Singleton <span class="token punctuation">{</span>    INSTANCE<span class="token punctuation">;</span>      <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">whateverMethod</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token punctuation">}</span>  <span class="token punctuation">}</span></code></pre><p>优点：线程安全，防止反序列化</p>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 单例 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>设计模式7大原则</title>
      <link href="/2020/04/30/she-ji-mo-shi-7-da-yuan-ze/"/>
      <url>/2020/04/30/she-ji-mo-shi-7-da-yuan-ze/</url>
      
        <content type="html"><![CDATA[<h1 id="设计模式7大原则"><a href="#设计模式7大原则" class="headerlink" title="设计模式7大原则"></a>设计模式7大原则</h1><h2 id="单一指责"><a href="#单一指责" class="headerlink" title="单一指责"></a>单一指责</h2><p><code>对类来说，既一个类应该只负责一项指责。如类A负责两个不同指责：指责1，指责2；当指责1需求变更而改变A时，可能造成指责2执行错误，所以需要将类A的粒度分解为A1，A2</code></p><p><code>软件设计应遵守单一职责原则，将不同的职责封装到不同的类或模块中</code></p><h2 id="开闭原则"><a href="#开闭原则" class="headerlink" title="开闭原则"></a>开闭原则</h2><p><code>开闭原则的意思是：**对扩展开放，对修改关闭**。在程序需要进行拓展的时候，不能去修改原有的代码，实现一个热插拔的效果。简言之，是为了使程序的扩展性好，易于维护和升级。想要达到这样的效果，我们需要使用接口和抽象类，后面的具体设计中我们会提到这点。</code></p><ul><li><p><code>通过扩展已有软件系统，可以提供新的行为，以满足对软件的新的需求，使变化中的软件有一定的适应性和灵活性。</code></p></li><li><p><code>已有软件模块，特别是最重要的抽象层模块不能再修改，这使变化中的软件系统有一定的稳定性和延续性` `实现开闭原则的关键在于 **分离不变和变化的部分，并对变化的部分进行合理的高层抽象，并让不变的部分依赖该高层抽象**，这样就能在不同的实现间切换，或者扩展新的实现。很多设计模式都体现了这一点，比如策略模式将算法抽象出来，模板方法将不变的算法骨架与易变的需要自定义的步骤隔离，装饰者模式将不变的核心功能对象和易变的增强功能隔离等等</code></p></li></ul><h2 id="里氏代换原则"><a href="#里氏代换原则" class="headerlink" title="里氏代换原则"></a>里氏代换原则</h2><p><code>里氏代换原则是面向对象设计的基本原则之一。 里氏代换原则中说，任何基类可以出现的地方，子类一定可以出现。LSP 是继承复用的基石，只有当派生类可以替换掉基类，且软件单位的功能不受到影响时，基类才能真正被复用，而派生类也能够在基类的基础上增加新的行为。里氏代换原则是对开闭原则的补充。实现开闭原则的关键步骤就是抽象化，而基类与子类的继承关系就是抽象化的具体实现，所以里氏代换原则是对实现抽象化的具体步骤的规范。</code></p><h2 id="依赖倒转原则"><a href="#依赖倒转原则" class="headerlink" title="依赖倒转原则"></a>依赖倒转原则</h2><p><code>这个原则是开闭原则的基础，具体内容：针对接口编程，依赖于抽象而不依赖于具体。</code></p><h2 id="接口隔离原则"><a href="#接口隔离原则" class="headerlink" title="接口隔离原则"></a>接口隔离原则</h2><p><code>这个原则的意思是：使用多个隔离的接口，比使用单个接口要好。它还有另外一个意思是：降低类之间的耦合度。由此可见，其实设计模式就是从大型软件架构出发、便于升级和维护的软件设计思想，它强调降低依赖，降低耦合。</code></p><h2 id="迪米特法则（最少知道原则）"><a href="#迪米特法则（最少知道原则）" class="headerlink" title="迪米特法则（最少知道原则）"></a>迪米特法则（最少知道原则）</h2><p><code>最少知道原则是指：一个实体应当尽量少地与其他实体之间发生相互作用，使得系统功能模块相对独立。</code></p><p><code>原则：只与直接的朋友进行通信</code></p><blockquote><p>直接的朋友：每个对象都会与其他对象有耦合关系，只要两个对象之间有耦合关系，我们就说这两个对象之间是朋友关系。耦合的方式很多，依赖，关联，组合，聚合等。其中，我们称出现<strong>成员变量，方法参数，方法返回值</strong>中的类为直接的朋友，而且现在<strong>局部变量中的类不是直接的朋友</strong>。也就是说，陌生的类最好不要以局部变量的形式出现在类的内部</p></blockquote><p>​     </p><h2 id="合称复用原则"><a href="#合称复用原则" class="headerlink" title="合称复用原则"></a>合称复用原则</h2><p><code>合成复用原则是指：尽量使用合成/聚合的方式，而不是使用继承。</code></p>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式七大原则 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>docker-simple</title>
      <link href="/2020/04/30/docker/"/>
      <url>/2020/04/30/docker/</url>
      
        <content type="html"><![CDATA[<h1 id="一、环境配置"><a href="#一、环境配置" class="headerlink" title="一、环境配置"></a>一、环境配置</h1><pre class=" language-shell"><code class="language-shell">1、检查内核版本，必须是3.10及以上 uname ‐r 2、安装docker yum install docker3、输入y确认安装4、启动docker [root@localhost ~]# systemctl start docker               [root@localhost ~]# docker ‐v                Docker version 1.12.6, build 3e8e77d/1.12.65、开机启动docker [root@localhost ~]# systemctl enable docker                  Created symlink from /etc/systemd/system/multi‐user.target.wants/docker.service to /usr/lib/systemd/system/docker.service. 6、停止docker systemctl stop docker</code></pre><p><img src="/images/docker/aliyun-docker.png" alt=""></p><h2 id="Docker常用命令-amp-操作"><a href="#Docker常用命令-amp-操作" class="headerlink" title="Docker常用命令&amp;操作"></a>Docker常用命令&amp;操作</h2><p><img src="/images/docker/simple.png" alt=""></p><h2 id="操作指令"><a href="#操作指令" class="headerlink" title="操作指令"></a>操作指令</h2><pre class=" language-shell"><code class="language-shell">1.搜索镜像 docker search tomcat 2.拉取镜像 docker pull tomcat 3.根据镜像启动容器 docker run --name mytomcat -d tomcat:latest 4.查看运行中的容器 docker ps 5.停止运行中的容器 docker stop 容器id 6.查看所有的容器 docker ps -a 7.启动容器 docker start 容器id 8.删除一个容器 docker rm 容器id 9.启动一个做了端口映射的tomcat docker run -d -p 8888:8080 tomcat 10.查看容器的日志 docker logs 容器id/容器名字 11.容器挂载 docker run --name mysql -v /conf/mysql:/etc/mysql mysql 12.进入容器 docker exec -it 容器id bash</code></pre><h2 id="迁移与备份"><a href="#迁移与备份" class="headerlink" title="迁移与备份"></a>迁移与备份</h2><pre class=" language-shell"><code class="language-shell">1.容器保存为镜像docker commit 现有容器id/容器名字 保存的镜像名字2.镜像备份docker save -o 保存的名字.tar 要保存的镜像3.镜像恢复与迁移docker load -i 要恢复的文件.tar</code></pre>]]></content>
      
      
      <categories>
          
          <category> docker </category>
          
      </categories>
      
      
        <tags>
            
            <tag> init </tag>
            
            <tag> simple syntax </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2020/04/28/hello-world/"/>
      <url>/2020/04/28/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><pre class=" language-bash"><code class="language-bash">$ hexo new <span class="token string">"My New Post"</span></code></pre><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><pre class=" language-bash"><code class="language-bash">$ hexo server</code></pre><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><pre class=" language-bash"><code class="language-bash">$ hexo generate</code></pre><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><pre class=" language-bash"><code class="language-bash">$ hexo deploy</code></pre><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> init </tag>
            
            <tag> simple syntax </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
