<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>shell概览</title>
      <link href="/2020/05/06/shell-gai-lan/"/>
      <url>/2020/05/06/shell-gai-lan/</url>
      
        <content type="html"><![CDATA[<h1 id="shell概览"><a href="#shell概览" class="headerlink" title="shell概览"></a>shell概览</h1><p><strong>shell 的两层含义：</strong><br>     既是一种应用程序,又是一种程序设计语言<br><strong>作为应用程序：</strong><br>      交互式地解释、执行用户输入的命令，将用户的操作翻译成机器可以识别的语言，完成相应功能<br><code>称之为 shell 命令解析器</code><br><code>shell 是用户和 Linux 内核之间的接口程序</code><br>用户在提示符下输入的命令都由 shell 先解释然后传给 Linux 核心<br>它调用了系统核心的大部分功能来执行程序、并以并行的方式协调各个程序的运行<br>Linux 系统中提供了好几种不同的 shell 命令解释器，如 sh、ash、bash 等。一般默认使用 bash 作为默认的解<br>释器。我们后面编写的 shell 脚本，都是由上述 shell 命令解释器解释执行的。<br><img src="/images/shell/shell_mode.png" alt=""><br>shell 是用户跟内核通信几种方式的一种<br><img src="/images/shell/shell_user.png" alt=""><br><code>作为程序设计语言：</code></p><p>它定义了各种变量和参数，并提供了许多在高级语言中才具有的控制结构，包括循环和分支<br>完成类似于 windows 下批处理操作，简化我们对系统的管理与应用程序的部署</p><p><strong><code>shell 脚本是一种脚本语言</code></strong>，我们只需使用任意文本编辑器，按照语法编写相应程序，增加可执行权限，即可在安<br>装 shell 命令解释器的环境下执行<br>shell 脚本主要用于：<br>帮助开发人员或系统管理员将复杂而又反复的操作放在一个文件中，通过简单的一步执行操作完成相应任务，从<br>而解放他们的负担</p><p><code>shell 脚本大体可以分为两类：</code><br><code>系统进行调用</code><br>这类脚本无需用户调用，系统会在合适的时候调用，如：/etc/profile、~/.bashrc 等</p><p>/etc/profile<br>       此文件为系统的每个用户设置环境信息,当用户第一次登录时,该文件被执行，系统的公共环境变量在这里设置<br>        开始自启动的程序，一般也在这里设置<br>~/.bashrc<br>       用户自己的家目录中的.bashrc<br>       登录时会自动调用，打开任意终端时也会自动调用<br>       这个文件一般设置与个人用户有关的环境变量，如交叉编译器的路径等等</p><p><code>用户编写，需要手动调用的</code><br>例如我们上面编写的脚本都属于此类<br>无论是系统调用的还是需要我们自己调用的，其语法规则都一样</p>]]></content>
      
      
      <categories>
          
          <category> shell </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>jvm基础参数</title>
      <link href="/2020/05/05/jvm-can-shu-zhi-nan/"/>
      <url>/2020/05/05/jvm-can-shu-zhi-nan/</url>
      
        <content type="html"><![CDATA[<h1 id="jvm参数指南"><a href="#jvm参数指南" class="headerlink" title="jvm参数指南"></a>jvm参数指南</h1><p><code>详情参考：</code><a href="https://docs.oracle.com/javase/8/docs/technotes/tools/unix/java.html" target="_blank" rel="noopener">https://docs.oracle.com/javase/8/docs/technotes/tools/unix/java.html</a></p><table><thead><tr><th>-Xms</th><th>初始化堆</th><th>默认占1/64</th></tr></thead><tbody><tr><td>-Xmx</td><td>最大堆</td><td>默认1/4</td></tr><tr><td>-Xmn</td><td>新生代最大可用</td><td>一般为1/3或1/4</td></tr><tr><td>-XX:NewRatio</td><td>老年代和新生代比例</td><td></td></tr><tr><td>-XX:SurvivorRatio</td><td>新生代中eden空间和from/to的比例</td><td></td></tr><tr><td>-Xss</td><td>单个线程栈</td><td>一般为512k-1024k</td></tr><tr><td>-XX:MetaspaceSize</td><td>元空间（本地内存）</td><td></td></tr><tr><td>-XX:MaxTenuringThreshold</td><td>垃圾最大年龄</td><td></td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> jvm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> jvm参数 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>垃圾收集算法</title>
      <link href="/2020/05/05/la-ji-shou-ji-suan-fa/"/>
      <url>/2020/05/05/la-ji-shou-ji-suan-fa/</url>
      
        <content type="html"><![CDATA[<h1 id="垃圾收集算法"><a href="#垃圾收集算法" class="headerlink" title="垃圾收集算法"></a>垃圾收集算法</h1><h2 id="1、引用计数法"><a href="#1、引用计数法" class="headerlink" title="1、引用计数法"></a>1、引用计数法</h2><p>引用计数法实现简单，效率较高，在大部分情况下是一个不错的算法。其原理是：给对象添加一个引用计数器，每当有一个地方引用该对象时，计数器加1，当引用失效时，计数器减1，当计数器值为0时表示该对象不再被使用。需要注意的是：引用计数法很难解决对象之间相互循环引用的问题，主流Java虚拟机没有选用引用计数法来管理内存。</p><p><strong>优点</strong>：引用计数收集器可以很快的执行，交织在程序运行中。对程序需要不被长时间打断的实时环境比较有利。</p><p><strong>缺点</strong>：无法检测出循环引用。如父对象有一个对子对象的引用，子对象反过来引用父对象。这样，他们的引用计数永远不可能为0。</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">abc_test</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        MyObject object1<span class="token operator">=</span><span class="token keyword">new</span> <span class="token class-name">MyObject</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        MyObject object2<span class="token operator">=</span><span class="token keyword">new</span> <span class="token class-name">MyObject</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        object1<span class="token punctuation">.</span>object<span class="token operator">=</span>object2<span class="token punctuation">;</span>        object2<span class="token punctuation">.</span>object<span class="token operator">=</span>object1<span class="token punctuation">;</span>             object1<span class="token operator">=</span>null<span class="token punctuation">;</span>        object2<span class="token operator">=</span>null<span class="token punctuation">;</span>            <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">class</span> <span class="token class-name">MyObject</span><span class="token punctuation">{</span>       MyObject object<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>这段代码是用来验证引用计数算法不能检测出循环引用。最后面两句将<code>object1</code>和<code>object2</code>赋值为<code>null</code>，也就是说<code>object1</code>和<code>object2</code>指向的对象已经不可能再被访问，但是由于它们互相引用对方，导致它们的引用计数器都不为0，那么垃圾收集器就永远不会回收它们</p><h2 id="2、标记-清除"><a href="#2、标记-清除" class="headerlink" title="2、标记-清除"></a>2、标记-清除</h2><p><img src="/images/JVM/garbage/%E6%A0%87%E8%AE%B0%E6%B8%85%E9%99%A4.png" alt=""></p><p>从图中可以很容易看出标记-清除算法实现起来比较容易，但是有一个比较严重的问题就是容易产生内存碎片，碎片太多可能会导致后续过程中需要为大对象分配空间时无法找到足够的空间而提前触发新的一次垃圾收集动作。  </p><p>标记-清除算法采用从根集合（GC Roots）进行扫描，对存活的对象进行标记，标记完毕后，再扫描整个空间中未被标记的对象，进行回收，如下图所示。标记-清除算法不需要进行对象的移动，只需对不存活的对象进行处理，在存活对象比较多的情况下极为高效，但由于标记-清除算法直接回收不存活的对象，因此会造成内存碎片。</p><h2 id="3、复制算法"><a href="#3、复制算法" class="headerlink" title="3、复制算法"></a>3、复制算法</h2><p>为了解决Mark-Sweep算法的缺陷，Copying算法就被提了出来。它将可用内存按容量划分为大小相等的两块，每次只使用其中的一块。当这一块的内存用完了，就将还存活着的对象复制到另外一块上面，然后再把已使用的内存空间一次清理掉，这样一来就不容易出现内存碎片的问题。具体过程如下图所示：</p><p><img src="/images/JVM/garbage/%E5%A4%8D%E5%88%B6%E7%AE%97%E6%B3%95.png" alt=""></p><p>这种算法虽然实现简单，运行高效且不容易产生内存碎片，但是却对内存空间的使用做出了高昂的代价，因为能够使用的内存缩减到原来的一半。</p><p>很显然，Copying算法的效率跟存活对象的数目多少有很大的关系，如果存活对象很多，那么Copying算法的效率将会大大降低。  </p><p>复制算法的提出是为了克服句柄的开销和解决内存碎片的问题。它开始时把堆分成 一个对象 面和多个空闲面， 程序从对象面为对象分配空间，当对象满了，基于copying算法的垃圾 收集就从根集合（GC Roots）中扫描活动对象，并将每个 活动对象复制到空闲面(使得活动对象所占的内存之间没有空闲洞)，这样空闲面变成了对象面，原来的对象面变成了空闲面，程序会在新的对象面中分配内存。</p><h2 id="4、标记-整理"><a href="#4、标记-整理" class="headerlink" title="4、标记-整理"></a>4、标记-整理</h2><p>为了解决Copying算法的缺陷，充分利用内存空间，提出了Mark-Compact算法。<strong>该算法标记阶段和Mark-Sweep一样，但是在完成标记之后，它不是直接清理可回收对象，而是将存活对象都向一端移动(美团面试题目，记住是完成标记之后，先不清理，先移动再清理回收对象)，然后清理掉端边界以外的内存(美团问过)</strong>   </p><p>标记-整理算法采用标记-清除算法一样的方式进行对象的标记，但在清除时不同，在回收不存活的对象占用的空间后，会将所有的存活对象往左端空闲空间移动，并更新对应的指针<strong>。标记-整理算法是在标记-清除算法的基础上，又进行了对象的移动</strong>，因此成本更高，但是却解决了内存碎片的问题。具体流程见下图：</p><p><img src="/images/JVM/garbage/%E6%A0%87%E8%AE%B0%E6%95%B4%E7%90%86.png" alt=""></p><h2 id="5、分代收集算法"><a href="#5、分代收集算法" class="headerlink" title="5、分代收集算法"></a>5、分代收集算法</h2><p>分代收集算法是目前大部分JVM的垃圾收集器采用的算法。它的核心思想是根据对象存活的生命周期将内存划分为若干个不同的区域。一般情况下将堆区划分为老年代（Tenured Generation）和新生代（Young Generation），在堆区之外还有一个代就是永久代（Permanet Generation）。老年代的特点是每次垃圾收集时只有少量对象需要被回收，而新生代的特点是每次垃圾回收时都有大量的对象需要被回收，那么就可以根据不同代的特点采取最适合的收集算法。</p><p>目前大部分垃圾收集器对于<strong>新生代都采取Copying算法</strong>，因为新生代中每次垃圾回收都要回收大部分对象，也就是说需要复制的操作次数较少<strong>，但是实际中并不是按照1：1的比例来划分新生代的空间的，一般来说是将新生代划分为一块较大的Eden空间和两块较小的Survivor空间（一般为8:1:1），每次使用Eden空间和其中的一块Survivor空间，当进行回收时，将Eden和Survivor中还存活的对象复制到另一块Survivor空间中，然后清理掉Eden和刚才使用过的Survivor空间</strong>。</p><p>而由于<strong>老年代的特点是每次回收都只回收少量对象，一般使用的是Mark-Compact算法。</strong></p><p><img src="/images/JVM/garbage/%E5%88%86%E4%BB%A3%E7%AE%97%E6%B3%95.png" alt=""></p><p><img src="/images/JVM/garbage/java8JVM.png" alt=""></p><h3 id="5-1、新生代和老年代的区别-阿里面试官的题目-："><a href="#5-1、新生代和老年代的区别-阿里面试官的题目-：" class="headerlink" title="5.1、新生代和老年代的区别(阿里面试官的题目)："></a>5.1、新生代和老年代的区别(<strong>阿里面试官的题目</strong>)：</h3><p>所谓的新生代和老年代是针对于分代收集算法来定义的，新生代又分为Eden和Survivor两个区。加上老年代就这三个区。数据会首先分配到Eden区 当中（当然也有特殊情况，如果是大对象那么会直接放入到老年代（大对象是指需要大量连续内存空间的java对象）。），当Eden没有足够空间的时候就会 触发jvm发起一次Minor GC。如果对象经过一次Minor GC还存活，并且又能被Survivor空间接受，那么将被移动到Survivor空 间当中。并将其年龄设为1，对象在Survivor每熬过一次Minor GC，年龄就加1，当年龄达到一定的程度（默认为15）时，就会被晋升到老年代 中了，当然晋升老年代的年龄是可以设置的。如果老年代满了就执行：Full GC 因为不经常执行，因此采用了 Mark-Compact算法清理</p><p>其实新生代和老年代就是针对于对象做分区存储，更便于回收等等</p>]]></content>
      
      
      <categories>
          
          <category> jvm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 垃圾收集算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>GCROOT</title>
      <link href="/2020/05/05/gcroot/"/>
      <url>/2020/05/05/gcroot/</url>
      
        <content type="html"><![CDATA[<h1 id="GCROOT"><a href="#GCROOT" class="headerlink" title="GCROOT"></a>GCROOT</h1><h2 id="1、什么是-GCROOT"><a href="#1、什么是-GCROOT" class="headerlink" title="1、什么是 GCROOT ?"></a>1、什么是 GCROOT ?</h2><p>1.1、什么是垃圾 ？</p><p>简单来说就是内存中已经不再使用到的空间就是垃圾</p><p>1.2、如何判断一个对象是否可以回收？</p><ul><li><code>引用计数法：</code></li></ul><p><img src="/images/JVM/GCROOT/%E5%BC%95%E7%94%A8%E8%AE%A1%E6%95%B0%E6%B3%95.png" alt=""></p><p>引用计数是垃圾收集器中的早期策略。在这种方法中，堆中每个对象实例都有一个引用计数。当一个对象被创建时，就将该对象实例分配给一个变量，该变量计数设置为1。当任何其它变量被赋值为这个对象的引用时，计数加1（a = b,则b引用的对象实例的计数器+1），但当一个对象实例的某个引用超过了生命周期或者被设置为一个新值时，对象实例的引用计数器减1。任何引用计数器为0的对象实例可以被当作垃圾收集。当一个对象实例被垃圾收集时，它引用的任何对象实例的引用计数器减1。</p><p><strong>优点</strong>：引用计数收集器可以很快的执行，交织在程序运行中。对程序需要不被长时间打断的实时环境比较有利。</p><p><strong>缺点</strong>：无法检测出循环引用。如父对象有一个对子对象的引用，子对象反过来引用父对象。这样，他们的引用计数永远不可能为0。</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">abc_test</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// TODO Auto-generated method stub</span>        MyObject object1<span class="token operator">=</span><span class="token keyword">new</span> <span class="token class-name">MyObject</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        MyObject object2<span class="token operator">=</span><span class="token keyword">new</span> <span class="token class-name">MyObject</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        object1<span class="token punctuation">.</span>object<span class="token operator">=</span>object2<span class="token punctuation">;</span>        object2<span class="token punctuation">.</span>object<span class="token operator">=</span>object1<span class="token punctuation">;</span>        object1<span class="token operator">=</span>null<span class="token punctuation">;</span>        object2<span class="token operator">=</span>null<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">class</span> <span class="token class-name">MyObject</span><span class="token punctuation">{</span>     MyObject object<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>这段代码是用来验证引用计数算法不能检测出循环引用。最后面两句将<code>object1</code>和<code>object2</code>赋值为<code>null</code>，也就是说<code>object1</code>和<code>object2</code>指向的对象已经不可能再被访问，但是由于它们互相引用对方，导致它们的引用计数器都不为0，那么垃圾收集器就永远不会回收它们</p><ul><li><code>可达性分析：</code></li></ul><p><img src="/images/JVM/GCROOT/gcroot_%E5%8F%AF%E8%BE%BE%E6%80%A7%E5%88%86%E6%9E%90.png" alt=""><br><img src="/images/JVM/GCROOT/GCROOT%E5%BC%95%E7%94%A8%E5%8F%AF%E8%BE%BE%E5%AF%B9%E8%B1%A1%E5%9B%BE%E8%A7%A3.png" alt=""></p><h2 id="2、GCROOT的作用域"><a href="#2、GCROOT的作用域" class="headerlink" title="2、GCROOT的作用域"></a>2、GCROOT的作用域</h2><p><img src="/images/JVM/GCROOT/GC%E7%9A%84%E4%BD%9C%E7%94%A8%E5%9F%9F.png" alt=""></p><p>在Java语言中，可作为GC Roots的对象包括下面几种：（京东）</p><p>  <code>a) 虚拟机栈中引用的对象（栈帧中的本地变量表）；</code></p><p>  <code>b) 方法区中类静态属性引用的对象；</code></p><p>  <code>c) 方法区中常量引用的对象；</code></p><p>  <code>d) 本地方法栈中JNI（Native方法）引用的对象。</code></p><p>Class-通过系统的类加载器加载的class。这种class是不可能被卸载的。它们可以通过静态数据域引用对象。这里需要注意的是，通过用户自定义的类加载器加载的Class并不能作为 GC Roots，除非相应的 java.lang.Class 的实例恰巧成为 GC Roots 对象。</p><p>即使在可达性分析算法中不可达的对象，也并非是“非死不可”的，这时候它们暂时处于“缓刑”阶段，要真正宣告一个对象死亡，至少要经历两次标记过程：如果对象在进行可达性分析后发现没有与GC Roots相连接的引用链，那它将会被第一次标记并且进行一次筛选，筛选的条件是此对象是否有必要执行finalize()方法。当对象没有覆盖finalize()方法，或者finalize()方法已经被虚拟机调用过，虚拟机将这两种情况都视为“没有必要执行”。程序中可以通过覆盖finalize()来一场”惊心动魄”的自我拯救过程，但是，这只有一次机会呦。</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** * 此代码演示了两点： * 1.对象可以在被GC时自我拯救。 * 2.这种自救的机会只有一次，因为一个对象的finalize()方法最多只会被系统自动调用一次  */</span>pubpc <span class="token keyword">class</span> <span class="token class-name">FinalizeEscapeGC</span> <span class="token punctuation">{</span>  pubpc <span class="token keyword">static</span> FinalizeEscapeGC SAVE_HOOK <span class="token operator">=</span> null<span class="token punctuation">;</span>  pubpc <span class="token keyword">void</span> <span class="token function">isApve</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"yes, i am still apve :)"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token annotation punctuation">@Override</span>  <span class="token keyword">protected</span> <span class="token keyword">void</span> <span class="token function">finalize</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> Throwable <span class="token punctuation">{</span>      <span class="token keyword">super</span><span class="token punctuation">.</span><span class="token function">finalize</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"finalize mehtod executed!"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      FinapzeEscapeGC<span class="token punctuation">.</span>SAVE_HOOK <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span>  pubpc <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> Throwable <span class="token punctuation">{</span>      SAVE_HOOK <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">FinalizeEscapeGC</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token comment" spellcheck="true">//对象第一次成功拯救自己</span>      SAVE_HOOK <span class="token operator">=</span> null<span class="token punctuation">;</span>      System<span class="token punctuation">.</span><span class="token function">gc</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token comment" spellcheck="true">//因为finapze方法优先级很低，所以暂停0.5秒以等待它</span>      Thread<span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">500</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token keyword">if</span> <span class="token punctuation">(</span>SAVE_HOOK <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>        SAVE_HOOK<span class="token punctuation">.</span><span class="token function">isApve</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"no, i am dead :("</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token punctuation">}</span>      <span class="token comment" spellcheck="true">//下面这段代码与上面的完全相同，但是这次自救却失败了</span>      SAVE_HOOK <span class="token operator">=</span> null<span class="token punctuation">;</span>      System<span class="token punctuation">.</span><span class="token function">gc</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token comment" spellcheck="true">//因为finapze方法优先级很低，所以暂停0.5秒以等待它</span>      Thread<span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">500</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token keyword">if</span> <span class="token punctuation">(</span>SAVE_HOOK <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>        SAVE_HOOK<span class="token punctuation">.</span><span class="token function">isApve</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"no, i am dead :("</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token punctuation">}</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>运行结果为：</p><pre class=" language-shell"><code class="language-shell">finalize mehtod executed! yes, i am still apve :)no, i am dead :(</code></pre>]]></content>
      
      
      <categories>
          
          <category> jvm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> GCROOT </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>抽象工厂模式</title>
      <link href="/2020/05/02/chou-xiang-gong-han-mo-shi/"/>
      <url>/2020/05/02/chou-xiang-gong-han-mo-shi/</url>
      
        <content type="html"><![CDATA[<h1 id="抽象工厂模式"><a href="#抽象工厂模式" class="headerlink" title="抽象工厂模式"></a>抽象工厂模式</h1><p>抽象工厂模式（Abstract Factory Pattern）是围绕一个超级工厂创建其他工厂。该超级工厂又称为其他工厂的工厂。这种类型的设计模式属于创建型模式，它提供了一种创建对象的最佳方式。</p><p>在抽象工厂模式中，接口是负责创建一个相关对象的工厂，不需要显式指定它们的类。每个生成的工厂都能按照工厂模式提供对象。</p><h2 id="需求"><a href="#需求" class="headerlink" title="需求"></a>需求</h2><p>我们将创建 <em>Shape</em> 和 <em>Color</em> 接口和实现这些接口的实体类。下一步是创建抽象工厂类 <em>AbstractFactory*。接着定义工厂类 *ShapeFactory</em> 和 <em>ColorFactory</em>，这两个工厂类都是扩展了 <em>AbstractFactory</em>。然后创建一个工厂创造器/生成器类 <em>FactoryProducer</em>。</p><p><em>AbstractFactoryPatternDemo*，我们的演示类使用 *FactoryProducer</em> 来获取 <em>AbstractFactory</em> 对象。它将向 <em>AbstractFactory</em> 传递形状信息 <em>Shape<em>（</em>CIRCLE / RECTANGLE / SQUARE*），以便获取它所需对象的类型。同时它还向 *AbstractFactory</em> 传递颜色信息 <em>Color</em>（<em>RED / GREEN / BLUE</em>），以便获取它所需对象的类型。</p><p><img src="/images/design/simpleFactory/simpleFactory.png" alt=""></p><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><h3 id="步骤-1"><a href="#步骤-1" class="headerlink" title="步骤 1"></a>步骤 1</h3><p>为形状创建一个接口。</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">Shape</span> <span class="token punctuation">{</span>    <span class="token keyword">void</span> <span class="token function">draw</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span></code></pre><h3 id="步骤-2"><a href="#步骤-2" class="headerlink" title="步骤 2"></a>步骤 2</h3><p>创建实现接口的实体类。</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Rectangle</span> <span class="token keyword">implements</span> <span class="token class-name">Shape</span> <span class="token punctuation">{</span>      <span class="token annotation punctuation">@Override</span>      <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">draw</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Inside Rectangle::draw() method."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token punctuation">}</span></code></pre><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Square</span> <span class="token keyword">implements</span> <span class="token class-name">Shape</span> <span class="token punctuation">{</span>       <span class="token annotation punctuation">@Override</span>      <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">draw</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Inside Square::draw() method."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token punctuation">}</span> <span class="token punctuation">}</span></code></pre><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Circle</span> <span class="token keyword">implements</span> <span class="token class-name">Shape</span> <span class="token punctuation">{</span>        <span class="token annotation punctuation">@Override</span>       <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">draw</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>              System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Inside Circle::draw() method."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>       <span class="token punctuation">}</span> <span class="token punctuation">}</span></code></pre><h3 id="步骤-3"><a href="#步骤-3" class="headerlink" title="步骤 3"></a>步骤 3</h3><p>为颜色创建一个接口。</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">Color</span> <span class="token punctuation">{</span>      <span class="token keyword">void</span> <span class="token function">fill</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><h3 id="步骤4"><a href="#步骤4" class="headerlink" title="步骤4"></a>步骤4</h3><p>创建实现接口的实体类。</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Red</span> <span class="token keyword">implements</span> <span class="token class-name">Color</span> <span class="token punctuation">{</span>        <span class="token annotation punctuation">@Override</span>        <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">fill</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>             System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Inside Red::fill() method."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token punctuation">}</span> <span class="token punctuation">}</span></code></pre><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Green</span> <span class="token keyword">implements</span> <span class="token class-name">Color</span> <span class="token punctuation">{</span>         <span class="token annotation punctuation">@Override</span>      <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">fill</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                  System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Inside Green::fill() method."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>       <span class="token punctuation">}</span> <span class="token punctuation">}</span></code></pre><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Blue</span> <span class="token keyword">implements</span> <span class="token class-name">Color</span> <span class="token punctuation">{</span>        <span class="token annotation punctuation">@Override</span>      <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">fill</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>           System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Inside Blue::fill() method."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token punctuation">}</span> <span class="token punctuation">}</span></code></pre><h3 id="步骤-5"><a href="#步骤-5" class="headerlink" title="步骤 5"></a>步骤 5</h3><p>为 Color 和 Shape 对象创建抽象类来获取工厂。</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">abstract</span> <span class="token keyword">class</span> <span class="token class-name">AbstractFactory</span> <span class="token punctuation">{</span>      <span class="token keyword">public</span> <span class="token keyword">abstract</span> Color <span class="token function">getColor</span><span class="token punctuation">(</span>String color<span class="token punctuation">)</span><span class="token punctuation">;</span>       <span class="token keyword">public</span> <span class="token keyword">abstract</span> Shape <span class="token function">getShape</span><span class="token punctuation">(</span>String shape<span class="token punctuation">)</span> <span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><h3 id="步骤-6"><a href="#步骤-6" class="headerlink" title="步骤 6"></a>步骤 6</h3><p>创建扩展了 AbstractFactory 的工厂类，基于给定的信息生成实体类的对象。</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ShapeFactory</span> <span class="token keyword">extends</span> <span class="token class-name">AbstractFactory</span> <span class="token punctuation">{</span>        <span class="token annotation punctuation">@Override</span>     <span class="token keyword">public</span> Shape <span class="token function">getShape</span><span class="token punctuation">(</span>String shapeType<span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>shapeType <span class="token operator">==</span> null<span class="token punctuation">)</span><span class="token punctuation">{</span>                <span class="token keyword">return</span> null<span class="token punctuation">;</span>            <span class="token punctuation">}</span>                     <span class="token keyword">if</span><span class="token punctuation">(</span>shapeType<span class="token punctuation">.</span><span class="token function">equalsIgnoreCase</span><span class="token punctuation">(</span><span class="token string">"CIRCLE"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>              <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">Circle</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>             <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span>shapeType<span class="token punctuation">.</span><span class="token function">equalsIgnoreCase</span><span class="token punctuation">(</span><span class="token string">"RECTANGLE"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                 <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">Rectangle</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>             <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span>shapeType<span class="token punctuation">.</span><span class="token function">equalsIgnoreCase</span><span class="token punctuation">(</span><span class="token string">"SQUARE"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                     <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">Square</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>             <span class="token punctuation">}</span>              <span class="token keyword">return</span> null<span class="token punctuation">;</span>      <span class="token punctuation">}</span>    <span class="token annotation punctuation">@Override</span>     <span class="token keyword">public</span> Color <span class="token function">getColor</span><span class="token punctuation">(</span>String color<span class="token punctuation">)</span> <span class="token punctuation">{</span>           <span class="token keyword">return</span> null<span class="token punctuation">;</span>       <span class="token punctuation">}</span> <span class="token punctuation">}</span></code></pre><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ColorFactory</span> <span class="token keyword">extends</span> <span class="token class-name">AbstractFactory</span> <span class="token punctuation">{</span>      <span class="token annotation punctuation">@Override</span>       <span class="token keyword">public</span> Shape <span class="token function">getShape</span><span class="token punctuation">(</span>String shapeType<span class="token punctuation">)</span><span class="token punctuation">{</span>          <span class="token keyword">return</span> null<span class="token punctuation">;</span>      <span class="token punctuation">}</span>        <span class="token annotation punctuation">@Override</span>      <span class="token keyword">public</span> Color <span class="token function">getColor</span><span class="token punctuation">(</span>String color<span class="token punctuation">)</span> <span class="token punctuation">{</span>             <span class="token keyword">if</span><span class="token punctuation">(</span>color <span class="token operator">==</span> null<span class="token punctuation">)</span><span class="token punctuation">{</span>                   <span class="token keyword">return</span> null<span class="token punctuation">;</span>            <span class="token punctuation">}</span>                      <span class="token keyword">if</span><span class="token punctuation">(</span>color<span class="token punctuation">.</span><span class="token function">equalsIgnoreCase</span><span class="token punctuation">(</span><span class="token string">"RED"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                 <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">Red</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>         <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span>color<span class="token punctuation">.</span><span class="token function">equalsIgnoreCase</span><span class="token punctuation">(</span><span class="token string">"GREEN"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                   <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">Green</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>              <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span>color<span class="token punctuation">.</span><span class="token function">equalsIgnoreCase</span><span class="token punctuation">(</span><span class="token string">"BLUE"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">Blue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>             <span class="token keyword">return</span> null<span class="token punctuation">;</span>    <span class="token punctuation">}</span> <span class="token punctuation">}</span></code></pre><h3 id="步骤-7"><a href="#步骤-7" class="headerlink" title="步骤 7"></a>步骤 7</h3><p>创建一个工厂创造器/生成器类，通过传递形状或颜色信息来获取工厂。</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">FactoryProducer</span> <span class="token punctuation">{</span>      <span class="token keyword">public</span> <span class="token keyword">static</span> AbstractFactory <span class="token function">getFactory</span><span class="token punctuation">(</span>String choice<span class="token punctuation">)</span><span class="token punctuation">{</span>              <span class="token keyword">if</span><span class="token punctuation">(</span>choice<span class="token punctuation">.</span><span class="token function">equalsIgnoreCase</span><span class="token punctuation">(</span><span class="token string">"SHAPE"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                 <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">ShapeFactory</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>               <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span>choice<span class="token punctuation">.</span><span class="token function">equalsIgnoreCase</span><span class="token punctuation">(</span><span class="token string">"COLOR"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                      <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">ColorFactory</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>             <span class="token punctuation">}</span>              <span class="token keyword">return</span> null<span class="token punctuation">;</span>     <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h3 id="步骤-8"><a href="#步骤-8" class="headerlink" title="步骤 8"></a>步骤 8</h3><p>使用 FactoryProducer 来获取 AbstractFactory，通过传递类型信息来获取实体类的对象。</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">AbstractFactoryPatternDemo</span> <span class="token punctuation">{</span>       <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">//获取形状工厂     </span>        AbstractFactory shapeFactory <span class="token operator">=</span> FactoryProducer<span class="token punctuation">.</span><span class="token function">getFactory</span><span class="token punctuation">(</span><span class="token string">"SHAPE"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>          <span class="token comment" spellcheck="true">//获取形状为 Circle 的对象    </span>        Shape shape1 <span class="token operator">=</span> shapeFactory<span class="token punctuation">.</span><span class="token function">getShape</span><span class="token punctuation">(</span><span class="token string">"CIRCLE"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">//调用 Circle 的 draw 方法     </span>        shape1<span class="token punctuation">.</span><span class="token function">draw</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>               <span class="token comment" spellcheck="true">//获取形状为 Rectangle 的对象     </span>        Shape shape2 <span class="token operator">=</span> shapeFactory<span class="token punctuation">.</span><span class="token function">getShape</span><span class="token punctuation">(</span><span class="token string">"RECTANGLE"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>           <span class="token comment" spellcheck="true">//调用 Rectangle 的 draw 方法    </span>        shape2<span class="token punctuation">.</span><span class="token function">draw</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token comment" spellcheck="true">//获取形状为 Square 的对象     </span>        Shape shape3 <span class="token operator">=</span> shapeFactory<span class="token punctuation">.</span><span class="token function">getShape</span><span class="token punctuation">(</span><span class="token string">"SQUARE"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>           <span class="token comment" spellcheck="true">//调用 Square 的 draw 方法     </span>        shape3<span class="token punctuation">.</span><span class="token function">draw</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>               <span class="token comment" spellcheck="true">//获取颜色工厂     </span>        AbstractFactory colorFactory <span class="token operator">=</span> FactoryProducer<span class="token punctuation">.</span><span class="token function">getFactory</span><span class="token punctuation">(</span><span class="token string">"COLOR"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>         <span class="token comment" spellcheck="true">//获取颜色为 Red 的对象   </span>        Color color1 <span class="token operator">=</span> colorFactory<span class="token punctuation">.</span><span class="token function">getColor</span><span class="token punctuation">(</span><span class="token string">"RED"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>           <span class="token comment" spellcheck="true">//调用 Red 的 fill 方法    </span>        color1<span class="token punctuation">.</span><span class="token function">fill</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>              <span class="token comment" spellcheck="true">//获取颜色为 Green 的对象    </span>        Color color2 <span class="token operator">=</span> colorFactory<span class="token punctuation">.</span><span class="token function">getColor</span><span class="token punctuation">(</span><span class="token string">"Green"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>           <span class="token comment" spellcheck="true">//调用 Green 的 fill 方法    </span>        color2<span class="token punctuation">.</span><span class="token function">fill</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>               <span class="token comment" spellcheck="true">//获取颜色为 Blue 的对象     </span>        Color color3 <span class="token operator">=</span> colorFactory<span class="token punctuation">.</span><span class="token function">getColor</span><span class="token punctuation">(</span><span class="token string">"BLUE"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>         <span class="token comment" spellcheck="true">//调用 Blue 的 fill 方法  </span>        color3<span class="token punctuation">.</span><span class="token function">fill</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>       <span class="token punctuation">}</span> <span class="token punctuation">}</span></code></pre><h3 id="步骤-9"><a href="#步骤-9" class="headerlink" title="步骤 9"></a>步骤 9</h3><p>执行程序，输出结果：</p><pre class=" language-java"><code class="language-java">Inside Circle<span class="token operator">:</span><span class="token operator">:</span><span class="token function">draw</span><span class="token punctuation">(</span><span class="token punctuation">)</span> method<span class="token punctuation">.</span>Inside Rectangle<span class="token operator">:</span><span class="token operator">:</span><span class="token function">draw</span><span class="token punctuation">(</span><span class="token punctuation">)</span> method<span class="token punctuation">.</span>Inside Square<span class="token operator">:</span><span class="token operator">:</span><span class="token function">draw</span><span class="token punctuation">(</span><span class="token punctuation">)</span> method<span class="token punctuation">.</span>Inside Red<span class="token operator">:</span><span class="token operator">:</span><span class="token function">fill</span><span class="token punctuation">(</span><span class="token punctuation">)</span> method<span class="token punctuation">.</span>Inside Green<span class="token operator">:</span><span class="token operator">:</span><span class="token function">fill</span><span class="token punctuation">(</span><span class="token punctuation">)</span> method<span class="token punctuation">.</span>Inside Blue<span class="token operator">:</span><span class="token operator">:</span><span class="token function">fill</span><span class="token punctuation">(</span><span class="token punctuation">)</span> method<span class="token punctuation">.</span></code></pre><hr><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p><strong>优点：</strong>当一个产品族中的多个对象被设计成一起工作时，它能保证客户端始终只使用同一个产品族中的对象。</p><p><strong>缺点：</strong>产品族扩展非常困难，要增加一个系列的某一产品，既要在抽象的 Creator 里加代码，又要在具体的里面加代码。</p><p><strong>使用场景：</strong> 1、QQ 换皮肤，一整套一起换。 2、生成不同操作系统的程序。</p>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 创建型模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>工厂模式</title>
      <link href="/2020/05/02/gong-han-mo-shi/"/>
      <url>/2020/05/02/gong-han-mo-shi/</url>
      
        <content type="html"><![CDATA[<h1 id="工厂模式"><a href="#工厂模式" class="headerlink" title="工厂模式"></a>工厂模式</h1><p>工厂模式（Factory Pattern）是 Java 中最常用的设计模式之一。这种类型的设计模式属于创建型模式，它提供了一种创建对象的最佳方式。</p><p>在工厂模式中，我们在创建对象时不会对客户端暴露创建逻辑，并且是通过使用一个共同的接口来指向新创建的对象</p><h2 id="需求"><a href="#需求" class="headerlink" title="需求"></a>需求</h2><p>我们将创建一个 <em>Shape</em> 接口和实现 <em>Shape</em> 接口的实体类。下一步是定义工厂类 <em>ShapeFactory</em>。</p><p><em>FactoryPatternDemo*，我们的演示类使用 *ShapeFactory</em> 来获取 <em>Shape</em> 对象。它将向 <em>ShapeFactory</em> 传递信息（<em>CIRCLE / RECTANGLE / SQUARE</em>），以便获取它所需对象的类型。</p><p><img src="/images/design/factory/factory.png" alt=""></p><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><h3 id="步骤-1："><a href="#步骤-1：" class="headerlink" title="步骤 1："></a>步骤 1：</h3><p>创建一个接口：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">Shape</span> <span class="token punctuation">{</span>   <span class="token keyword">void</span> <span class="token function">draw</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><h3 id="步骤-2："><a href="#步骤-2：" class="headerlink" title="步骤 2："></a>步骤 2：</h3><p>创建实现接口的实现类：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Rectangle</span> <span class="token keyword">implements</span> <span class="token class-name">Shape</span> <span class="token punctuation">{</span>   <span class="token annotation punctuation">@Override</span>   <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">draw</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>      System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Inside Rectangle::draw() method."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Square</span> <span class="token keyword">implements</span> <span class="token class-name">Shape</span> <span class="token punctuation">{</span>   <span class="token annotation punctuation">@Override</span>   <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">draw</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>      System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Inside Square::draw() method."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Circle</span> <span class="token keyword">implements</span> <span class="token class-name">Shape</span> <span class="token punctuation">{</span>   <span class="token annotation punctuation">@Override</span>   <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">draw</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>      System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Inside Circle::draw() method."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h3 id="步骤-3："><a href="#步骤-3：" class="headerlink" title="步骤 3："></a>步骤 3：</h3><p>创建一个工厂，生成基于给定信息的实体类的对象：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ShapeFactory</span> <span class="token punctuation">{</span>   <span class="token comment" spellcheck="true">//使用 getShape 方法获取形状类型的对象</span>   <span class="token keyword">public</span> Shape <span class="token function">getShape</span><span class="token punctuation">(</span>String shapeType<span class="token punctuation">)</span><span class="token punctuation">{</span>      <span class="token keyword">if</span><span class="token punctuation">(</span>shapeType <span class="token operator">==</span> null<span class="token punctuation">)</span><span class="token punctuation">{</span>         <span class="token keyword">return</span> null<span class="token punctuation">;</span>      <span class="token punctuation">}</span>              <span class="token keyword">if</span><span class="token punctuation">(</span>shapeType<span class="token punctuation">.</span><span class="token function">equalsIgnoreCase</span><span class="token punctuation">(</span><span class="token string">"CIRCLE"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>         <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">Circle</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span>shapeType<span class="token punctuation">.</span><span class="token function">equalsIgnoreCase</span><span class="token punctuation">(</span><span class="token string">"RECTANGLE"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>         <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">Rectangle</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span>shapeType<span class="token punctuation">.</span><span class="token function">equalsIgnoreCase</span><span class="token punctuation">(</span><span class="token string">"SQUARE"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>         <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">Square</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token punctuation">}</span>      <span class="token keyword">return</span> null<span class="token punctuation">;</span>   <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h3 id="步骤-4"><a href="#步骤-4" class="headerlink" title="步骤 4:"></a>步骤 4:</h3><p>使用该工厂，通过传递类型信息来获取实体类的对象:</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">FactoryPatternDemo</span> <span class="token punctuation">{</span>   <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>      ShapeFactory shapeFactory <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ShapeFactory</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token comment" spellcheck="true">//获取 Circle 的对象，并调用它的 draw 方法</span>      Shape shape1 <span class="token operator">=</span> shapeFactory<span class="token punctuation">.</span><span class="token function">getShape</span><span class="token punctuation">(</span><span class="token string">"CIRCLE"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token comment" spellcheck="true">//调用 Circle 的 draw 方法</span>      shape1<span class="token punctuation">.</span><span class="token function">draw</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token comment" spellcheck="true">//获取 Rectangle 的对象，并调用它的 draw 方法</span>      Shape shape2 <span class="token operator">=</span> shapeFactory<span class="token punctuation">.</span><span class="token function">getShape</span><span class="token punctuation">(</span><span class="token string">"RECTANGLE"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token comment" spellcheck="true">//调用 Rectangle 的 draw 方法</span>      shape2<span class="token punctuation">.</span><span class="token function">draw</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token comment" spellcheck="true">//获取 Square 的对象，并调用它的 draw 方法</span>      Shape shape3 <span class="token operator">=</span> shapeFactory<span class="token punctuation">.</span><span class="token function">getShape</span><span class="token punctuation">(</span><span class="token string">"SQUARE"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token comment" spellcheck="true">//调用 Square 的 draw 方法</span>      shape3<span class="token punctuation">.</span><span class="token function">draw</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h3 id="步骤-5："><a href="#步骤-5：" class="headerlink" title="步骤 5："></a>步骤 5：</h3><p>执行程序，输出结果：</p><pre class=" language-java"><code class="language-java">Inside Circle<span class="token operator">:</span><span class="token operator">:</span><span class="token function">draw</span><span class="token punctuation">(</span><span class="token punctuation">)</span> method<span class="token punctuation">.</span>Inside Rectangle<span class="token operator">:</span><span class="token operator">:</span><span class="token function">draw</span><span class="token punctuation">(</span><span class="token punctuation">)</span> method<span class="token punctuation">.</span>Inside Square<span class="token operator">:</span><span class="token operator">:</span><span class="token function">draw</span><span class="token punctuation">(</span><span class="token punctuation">)</span> method<span class="token punctuation">.</span></code></pre><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p><strong>优点：</strong> 1、一个调用者想创建一个对象，只要知道其名称就可以了。 2、扩展性高，如果想增加一个产品，只要扩展一个工厂类就可以。 3、屏蔽产品的具体实现，调用者只关心产品的接口。</p><p><strong>缺点：</strong>每次增加一个产品时，都需要增加一个具体类和对象实现工厂，使得系统中类的个数成倍增加，在一定程度上增加了系统的复杂度，同时也增加了系统具体类的依赖。这并不是什么好事。</p><p><strong>使用场景：</strong> 1、日志记录器：记录可能记录到本地硬盘、系统事件、远程服务器等，用户可以选择记录日志到什么地方。 2、数据库访问，当用户不知道最后系统采用哪一类数据库，以及数据库可能有变化时。 3、设计一个连接服务器的框架，需要三个协议，”POP3”、”IMAP”、”HTTP”，可以把这三个作为产品类，共同实现一个接口。</p>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 创建型模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>油猴脚本</title>
      <link href="/2020/05/02/tampermonkey/"/>
      <url>/2020/05/02/tampermonkey/</url>
      
        <content type="html"><![CDATA[<h1 id="Tampermonkey"><a href="#Tampermonkey" class="headerlink" title="Tampermonkey"></a>Tampermonkey</h1><p>  <strong>Tampermonkey</strong> 是一款免费的浏览器扩展和最为流行的用户脚本管理器，它适用于 <a href="https://www.tampermonkey.net/#" target="_blank" rel="noopener"><strong>Chrome</strong></a>, <a href="https://www.tampermonkey.net/#" target="_blank" rel="noopener"><strong>Microsoft Edge</strong></a>, <a href="https://www.tampermonkey.net/#" target="_blank" rel="noopener"><strong>Safari</strong></a>, <a href="https://www.tampermonkey.net/#" target="_blank" rel="noopener"><strong>Opera Next</strong></a>, 和 <a href="https://www.tampermonkey.net/#" target="_blank" rel="noopener"><strong>Firefox</strong></a>。</p><p>虽然有些受支持的浏览器拥有原生的用户脚本支持，但 Tampermonkey 将在您的用户脚本管理方面提供更多的便利。 它提供了诸如便捷脚本安装、自动更新检查、标签中的脚本运行状况速览、内置的编辑器等众多功能， 同时Tampermonkey还有可能正常运行原本并不兼容的脚本。  </p><p>我常用的用户脚本:   <a href="/download/tampermonkey_scripts.zip"">下载</a><br>ps:下载不了的，请打开 -开发者工具- 下载</p><p>寻找脚本网址：</p><p>​     1.<a href="https://github.com/" target="_blank" rel="noopener">https://github.com/</a></p><p>​     2.<a href="https://openuserjs.org/" target="_blank" rel="noopener">https://openuserjs.org/</a></p><p>​     3.<a href="https://greasyfork.org/" target="_blank" rel="noopener">https://greasyfork.org/</a></p><p>​     4.<a href="https://gist.github.com/search?l=JavaScript&amp;o=desc&amp;q=%22%3D%3DUserScript%3D%3D%22&amp;s=updated" target="_blank" rel="noopener">https://gist.github.com/search?l=JavaScript&amp;o=desc&amp;q=%22%3D%3DUserScript%3D%3D%22&amp;s=updated</a></p><p>​     5.最后一点,你可以使用搜索引擎来搜索脚本资源,比如输入需要运行脚本的网站的主域名和后缀 “.user.js” </p>]]></content>
      
      
      <categories>
          
          <category> Tampermonkey </category>
          
      </categories>
      
      
        <tags>
            
            <tag> init </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ssr订阅分享</title>
      <link href="/2020/05/02/ssr-ding-yue-fen-xiang/"/>
      <url>/2020/05/02/ssr-ding-yue-fen-xiang/</url>
      
        <content type="html"><![CDATA[<h1 id="ssr订阅分享"><a href="#ssr订阅分享" class="headerlink" title="ssr订阅分享"></a>ssr订阅分享</h1><p><strong>ZCSSR : <a href="https://zc17.xyz/auth/register?code=NoUD" target="_blank" rel="noopener">https://zc17.xyz/auth/register?code=NoUD</a></strong></p><p><strong>彼岸花：</strong><a href="https://bianhuaho.com/auth/register?code=7zqF" target="_blank" rel="noopener">https://bianhuaho.com/auth/register?code=7zqF</a></p><p><strong>T云速：</strong><a href="https://asfsdgfdfhgdfhdfsdfsd.xyz/auth/register?code=xgD4" target="_blank" rel="noopener">https://asfsdgfdfhgdfhdfsdfsd.xyz/auth/register?code=xgD4</a></p><p><strong>科学云：</strong><a href="https://subsice.site/auth/register?code=ZmiN" target="_blank" rel="noopener">https://subsice.site/auth/register?code=ZmiN</a></p><p><strong>优云666：</strong><a href="https://youyun666.com/auth/register?code=I1HE" target="_blank" rel="noopener">https://youyun666.com/auth/register?code=I1HE</a></p><p><strong>速鹰666：</strong><a href="https://youyun666.com/auth/register?code=I1HE" target="_blank" rel="noopener">https://youyun666.com/auth/register?code=I1HE</a></p><p><strong>lncn：</strong><a href="https://lncn.org/" target="_blank" rel="noopener">https://lncn.org/</a></p>]]></content>
      
      
      <categories>
          
          <category> ssr </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 机场 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ssr - window 教程</title>
      <link href="/2020/05/02/chang-jian-ssr-window-jiao-cheng/"/>
      <url>/2020/05/02/chang-jian-ssr-window-jiao-cheng/</url>
      
        <content type="html"><![CDATA[<h1 id="常见-ssr-window-教程"><a href="#常见-ssr-window-教程" class="headerlink" title="常见 ssr  -  window 教程"></a>常见 ssr  -  window 教程</h1><h2 id="1-下载及说明"><a href="#1-下载及说明" class="headerlink" title="1.下载及说明"></a>1.下载及说明</h2><p><a href="https://github.com/shadowsocksr-backup/shadowsocksr-csharp/releases" target="_blank" rel="noopener">下载</a></p><p><img src="/images/ssr/assets/folder.png" alt=""></p><p><code>注：演示版本为4.7.0</code></p><p>目录说明：</p><p>​     templates : shadowsocksR的页面模板文件（页面，无特殊情况请勿修改）</p><p>​     chn_ip.txt ：记录中国ip范围，用于那些该放行</p><p>​     2.0.exe  :  xp系统请选择</p><p>​     4.0.exe  :  如果你的电脑上已经安装了NET Framework 4.0,请选择</p><p>​     .sig  ：文件为MD5校验文件</p><p>​     user.rule : 放行规则文件</p><h2 id="2-功能、设置说明"><a href="#2-功能、设置说明" class="headerlink" title="2.功能、设置说明"></a>2.功能、设置说明</h2><p>右击小飞机，你能看到 SSR 所有的功能选项，以下是各项功能及设置的介绍。</p><h3 id="系统代理模式"><a href="#系统代理模式" class="headerlink" title="系统代理模式"></a>系统代理模式</h3><p>系统代理模式有四种模式可以选择：</p><p><strong>直连模式</strong><br>会关闭系统HTTP代理，你的所有HTTP上网流量都不会通过 SSR 代理，在此模式下你只能使用Socks5代理方式连接 SSR 代理。</p><ul><li><p><strong>PAC模式</strong><br>会修改系统IE代理，使用PAC文件控制代理。PAC文件包含了规则列表，可以控制哪些流量走 SSR，哪些不走（例如国内流量直连，国外走代理），做到智能代理。<strong>但是实际上此功能已经可以被“代理规则”设置完全代替（除非你一定要用gfwlist），因此一般不用这一模式。</strong><br>PAC文件为 SSR 根目录下的<code>pac.txt</code>。</p></li><li><p><strong>全局模式</strong><br>会开启系统HTTP代理，你的所有HTTP上网流量将会通过 SSR 代理。<br>注意：仅能代理HTTP流量，即浏览网页的流量——例如浏览器浏览网页，或者某些应用程序的应用内网页（比如QQ的群文件、群公告这些就是），或者某些比较奇葩的使用HTTP方式进行通信的程序（比如Steam版的影之诗）。</p></li><li><p><strong>保持当前状态不修改</strong><br>顾名思义，不会对你目前的系统HTTP代理状态进行任何的修改。</p></li></ul><p>当你退出 SSR 后，系统HTTP代理会自动被恢复至原有状态；开启 SSR 后，同样的，系统HTTP代理会被设置成你所设定的系统代理模式状态。</p><h3 id="PAC"><a href="#PAC" class="headerlink" title="PAC"></a>PAC</h3><p>此菜单中的选项均为对 SSR 的PAC文件进行操作的选项，如果你不使用“PAC模式”代理，那么这一节你可以直接跳过。</p><p>不过实际上也没什么好讲的，每个选项会执行什么操作、有什么效果，都在菜单中写的清清楚楚。</p><p><img src="/images/ssr/assets/common.jpg" alt=""></p><h3 id="代理规则"><a href="#代理规则" class="headerlink" title="代理规则"></a>代理规则</h3><p>代理规则指的是，对于所有通过系统HTTP代理或者SOCKS5代理被发送至 SSR 的流量，按照你设置的规则进行代理，即智能代理。</p><p>实际上这个设置项也没有什么可以说明的内容，每个选项也写的很清楚。这里稍微解释下某些名词及选项：</p><ul><li><strong>绕过xxx</strong><br>顾名思义，绕过就是不走代理，例如选择项中的“绕过局域网“就是当你浏览局域网网页的时候不会走 SSR 代理（最常见的例如学校、公司的内部网网页），”绕过大陆“就是所有国内大陆的流量都不会通过 SSR 代理。</li><li><strong>绕过非大陆</strong><br>带有这个的一项实际上是给从国外翻回来的人用的，我们这些翻出去的并用不到。</li><li><strong>用户自定义</strong><br>萌新可以直接无视这一项。自定义文件为 SSR 根目录下的<code>user-rule.txt</code>，你可以在这一文件中自己定义代理规则，格式详见：<a href="https://adblockplus.org/en/filter-cheatsheet" target="_blank" rel="noopener">https://adblockplus.org/en/filter-cheatsheet</a></li><li><strong>全局</strong><br>顾名思义，所有被发送至 SSR 的流量都会走代理。</li></ul><p>日常使用我推荐使用“绕过局域网和大陆”的选项</p><h3 id="服务器"><a href="#服务器" class="headerlink" title="服务器"></a>服务器</h3><p>在这里你可以切换你已有的服务器配置，在你第一次使用的时候别忘了先切换至你自己添加的服务器配置。</p><ul><li><p><strong>编辑服务器</strong><br>直接双击小飞机也可以打开编辑窗口。</p></li><li><p><strong>从文件导入服务器</strong><br>可以导入 SSR 服务商提供的服务器配置文件。</p></li><li><p><strong>服务器连接统计</strong><br>直接鼠标中键单机小飞机也可以打开这一窗口，会显示你目前 SSR 的所有服务器的统计信息。</p><p><img src="/images/ssr/assets/common(1).png" alt=""></p><p>在这一界面，双击某个条目的服务器可以直接切换至该服务器；<br>单击某一条目的“连接”可以断开当前条目的所有连接；<br>双击某一条目的“开关”可以指定你在设置服务器负载均衡时是否使用这一服务器，而双击某一个“组”(Group)可以批量开关这一组；<br>双击某一条目其他的列可以清零这一统计信息。</p></li></ul><h3 id="服务器订阅"><a href="#服务器订阅" class="headerlink" title="服务器订阅"></a>服务器订阅</h3><p>此处可以设置服务器订阅，初次使用请先删掉自带的服务器订阅（已经失效）。</p><p>如果你没有从 SSR 提供商处获得 SSR 服务器订阅地址，那么可以直接跳过本节。</p><ul><li><strong>SSR 服务器订阅设置</strong><br>点击“ADD”，然后在右侧填入你的 SSR 服务器订阅地址，即可添加一条服务器订阅，然后直接点击确定即可。如果你勾选了左下角的“自动更新”，在每次 SSR 启动的时候都会自动更新订阅，一般情况下无需选择。</li><li><strong>更新服务器订阅</strong><br>将会从已经设置的订阅地址中获取配置信息自动添加/更新至服务器配置中，<strong>并且此操作会通过你当前的 SSR 代理进行！</strong>如果你目前的 SSR 代理不是可用的代理，那么将会更新失败！<strong>因此建议选择“更新服务器订阅（不通过代理）”。</strong>一般只有 SSR 服务器订阅地址不能在墙内访问而你有可以使用的 SSR 代理配置的时候才需要使用 SSR 代理更新订阅。</li></ul><h3 id="服务器负载均衡"><a href="#服务器负载均衡" class="headerlink" title="服务器负载均衡"></a>服务器负载均衡</h3><p>这是个基本不会用到的功能。选中以后，在每次有流量通过 SSR 代理时，会自动在没有被“关掉”的代理中选择一个来使用。</p><p>如果想只在某一组服务器中切换，或者依据一定的条件来切换服务器，请右击小飞机-选项设置，然后看“负载均衡”的设置。</p><h3 id="选项设置"><a href="#选项设置" class="headerlink" title="选项设置"></a>选项设置</h3><ul><li><strong>二级（前置）代理</strong><br>使用代理来连接代理，就像盗梦空间那样。没有特殊需求就不用管这一项。</li><li><strong>负载均衡</strong><br>没什么好说的，每个设置有什么用都写的简单明了。</li><li><strong>本地代理</strong><br>这是个很重要的设置项。<br>本地代理实际上就是在本机(127.0.0.1)开启一个SOCKS5代理端口，端口为“本地端口”设置项中的端口号。<br>如果勾选了“允许来自局域网的连接”，则与你在同一局域网的其他设备一可以通过这一SOCKS5代理来连接，服务器地址为你的局域网IP地址。<br>用户名和密码选填，如果你设置了，那么当你使用SOCKS5代理的时候就需要这一用户名密码了。</li><li><strong>右下角的设置</strong><br>没啥好说的（。</li></ul><h3 id="端口设置"><a href="#端口设置" class="headerlink" title="端口设置"></a>端口设置</h3><p>可以设置端口转发以及对于不同的服务器配置开启不同的本地代理SOCKS5端口等等。萌新直接不用管。</p><h3 id="二维码扫描"><a href="#二维码扫描" class="headerlink" title="二维码扫描"></a>二维码扫描</h3><p>可以扫描屏幕上的 SSR 配置信息二维码并导入服务器配置中。二维码通常由你的 SSR 供应商提供。</p><h3 id="剪贴板批量导入ssr-链接"><a href="#剪贴板批量导入ssr-链接" class="headerlink" title="剪贴板批量导入ssr://链接"></a>剪贴板批量导入ssr://链接</h3><p>没啥好讲的，如果你的 SSR 供应商有提供批量 SSR 服务器配置链接，你就可以复制之后通过这里导入。</p><h3 id="帮助"><a href="#帮助" class="headerlink" title="帮助"></a>帮助</h3><p>由于众所周知的原因，破娃酱已经删除了 Github 上的所有 SSR 项目，并且停止了对 SSR 的开发及维护，因此这里的什么“检查更新”啊“打开 Wiki 文档”啊都是已经没用了的选项。</p><p><a href="https://github.com/shadowsocksr-backup/shadowsocks-rss/wiki" target="_blank" rel="noopener">https://github.com/shadowsocksr-backup/shadowsocks-rss/wiki</a><br>以上是 Wiki 文档备份</p><ul><li><strong>显示日志</strong><br>显示 SSR 通信日志。</li><li><strong>自定义生成二维码</strong><br>这就是一个生成二维码的小工具而已。</li><li><strong>设置客户端密码</strong><br>为你的 SSR 客户端设置密码保护。</li></ul><h2 id="3-常见问题"><a href="#3-常见问题" class="headerlink" title="3.常见问题"></a>3.常见问题</h2><h3 id="无法更新-PAC"><a href="#无法更新-PAC" class="headerlink" title="无法更新 PAC"></a>无法更新 PAC</h3><p>因在线更新的 PAC 所在的项目均已被删除，因此酸酸乳自带的 PAC 更新功能已无法使用，你可以换用 SSRR 客户端</p><h3 id="使用了代理之后查询自己的-IP-发现还是国内的"><a href="#使用了代理之后查询自己的-IP-发现还是国内的" class="headerlink" title="使用了代理之后查询自己的 IP 发现还是国内的"></a>使用了代理之后查询自己的 IP 发现还是国内的</h3><p>你大概是直接去百度“IP”或者使用了国内的查询IP的服务，而且你的 SSR 代理模式设置的是“绕过大陆”。</p><p>请将代理模式改为“全局”后再试，或者访问位于国外的 IP 查询服务网站例如 <a href="https://ip.sb/" target="_blank" rel="noopener">https://ip.sb</a></p><h3 id="打开-SSR-提示xxxx端口已被占用"><a href="#打开-SSR-提示xxxx端口已被占用" class="headerlink" title="打开 SSR 提示xxxx端口已被占用"></a>打开 SSR 提示xxxx端口已被占用</h3><p>你的 SSR 的 SOCKS5 端口被系统中的其他程序占用了，去更改 SSR选项设置 中的本地端口吧。推荐改为 1025~65535 之间的端口（1024之前的端口有系统保留端口，防止误占用）。</p><h3 id="无法更新-SSR-服务器订阅"><a href="#无法更新-SSR-服务器订阅" class="headerlink" title="无法更新 SSR 服务器订阅"></a>无法更新 SSR 服务器订阅</h3><p><strong>在关闭代理的情况下</strong>，直接把你的订阅网址扔到浏览器里，看看是否能正常访问，正常情况下会直接显示一串毫无规律的英文数字或者弹出一个文件下载框。</p><ul><li><strong>能√</strong><br>解决方法：选择“更新 SSR 服务器订阅<strong>（不通过代理）</strong>”<br>问题分析：你可能是在还没有添加有效服务器配置的时候直接选择了“更新 SSR 服务器订阅”。<br>如果不选含有“（不通过代理）”的那一项，那么 SSR <strong>默认将会通过代理来更新订阅</strong>，然而你并没有有效的服务器配置，因此自然就无法更新了。</li><li><strong>不能×</strong><br>那么检查一下你是不是手打打错了或者复制少了一部分网址……<br>如果你很确信订阅地址没有错，如果你有可用的代理配置的话，就尝试通过代理更新订阅。<br>如果还是不行，请找到你的 SSR 代理商询问原因。</li></ul><h3 id="正确添加了配置，但无法正常使用代理上网"><a href="#正确添加了配置，但无法正常使用代理上网" class="headerlink" title="正确添加了配置，但无法正常使用代理上网"></a>正确添加了配置，但无法正常使用代理上网</h3><p>逐步排查问题：</p><ol><li><p><strong>计算机中是否有安装程序所需依赖</strong><br>例如 .NET 以及 VC++运行环境 之类的，特别是 VC++ 运行环境，当你没安装的时候可以打开程序，但是你看日志会有报错，无法使用各种加密</p></li><li><p>你可能根本就连不上你的ss代理服务器</p><p>打开命令提示符（Win+R打开“运行”，输入</p><pre><code>cmd</code></pre><p>然后回车Enter，接着输入</p><pre><code>ping 你的SSR服务器地址</code></pre><p>然后回车，查看是否能Ping通，否则说明你目前的网络情况根本无法连接代理。<br><em>New: 目前 GFW 开始使用 TCP 阻断的方式</em></p></li><li><p><strong>你的SSR配置可能不正确</strong><br>如果你是手动填写的配置而不是通过SSR提供商的一键配置来添加，那可能会出现这种情况，请检查一下你的配置是否正确。</p></li><li><p><strong>SSR的系统代理模式和代理规则是否正确</strong><br>通常来讲推荐萌新的设置是，系统代理模式选择“全局模式”，代理规则选择“绕过局域网和大陆”。</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> ssr </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ssr-window </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>单例设计模式</title>
      <link href="/2020/04/30/dan-li-mo-shi/"/>
      <url>/2020/04/30/dan-li-mo-shi/</url>
      
        <content type="html"><![CDATA[<h1 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h1><p>单例模式（Singleton Pattern）是 Java 中最简单的设计模式之一。这种类型的设计模式属于创建型模式，它提供了一种创建对象的最佳方式。</p><p>这种模式涉及到一个单一的类，该类负责创建自己的对象，同时确保只有单个对象被创建。这个类提供了一种访问其唯一的对象的方式，可以直接访问，不需要实例化该类的对象。</p><p><strong>注意：</strong></p><p>1、单例类只能有一个实例。</p><p>2、单例类必须自己创建自己的唯一实例。</p><p>3、单例类必须给所有其他对象提供这一实例。</p><p><strong>优点：</strong></p><p>1、在内存里只有一个实例，减少了内存的开销，尤其是频繁的创建和销毁实例</p><p>2、避免对资源的多重占用（比如写文件操作）。</p><p><strong>缺点：</strong></p><p> 1、没有接口，不能继承，与单一职责原则冲突，一个类应该只关心内部逻辑，而不关心外面怎么样来实例化。</p><hr><h2 id="饿汉式（静态常量-静态代码块）"><a href="#饿汉式（静态常量-静态代码块）" class="headerlink" title="饿汉式（静态常量/静态代码块）"></a>饿汉式（静态常量/静态代码块）</h2><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Singleton</span> <span class="token punctuation">{</span>   <span class="token comment" spellcheck="true">//创建 Single 的一个对象</span>   <span class="token keyword">private</span> <span class="token keyword">static</span> Singleton instance <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Singleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">//让构造函数为 private，这样该类就不会被实例化</span>   <span class="token keyword">private</span> <span class="token function">Singleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span>   <span class="token comment" spellcheck="true">//获取唯一可用的对象</span>   <span class="token keyword">public</span> <span class="token keyword">static</span> Singleton <span class="token function">getInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>      <span class="token keyword">return</span> instance<span class="token punctuation">;</span>   <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p><strong>优点：</strong>比较简单，在类装载时完成实例化，避免了线程同步问题</p><p><strong>缺点：</strong>在类装载时完成初始化，没有达到 Lazy Loading 的效果，可能造成内存浪费</p><hr><h2 id="懒汉式（同步方法-不推荐）"><a href="#懒汉式（同步方法-不推荐）" class="headerlink" title="懒汉式（同步方法/不推荐）"></a>懒汉式（同步方法/不推荐）</h2><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Singleton</span> <span class="token punctuation">{</span>      <span class="token keyword">private</span> <span class="token keyword">static</span> Singleton instance<span class="token punctuation">;</span>      <span class="token keyword">private</span> <span class="token function">Singleton</span> <span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span>      <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">synchronized</span> Singleton <span class="token function">getInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>         <span class="token keyword">if</span> <span class="token punctuation">(</span>instance <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>            instance <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Singleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>         <span class="token punctuation">}</span>         <span class="token keyword">return</span> instance<span class="token punctuation">;</span>      <span class="token punctuation">}</span>  <span class="token punctuation">}</span></code></pre><p><strong>优点：</strong>解决了传统懒汉式的线程问题</p><p><strong>缺点：</strong>同步方法效率低下</p><hr><h2 id="双重检测（推荐）"><a href="#双重检测（推荐）" class="headerlink" title="双重检测（推荐）"></a>双重检测（推荐）</h2><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Singleton</span> <span class="token punctuation">{</span>      <span class="token keyword">private</span> <span class="token keyword">volatile</span> <span class="token keyword">static</span> Singleton singleton<span class="token punctuation">;</span>      <span class="token keyword">private</span> <span class="token function">Singleton</span> <span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span>      <span class="token keyword">public</span> <span class="token keyword">static</span> Singleton <span class="token function">getSingleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>         <span class="token keyword">if</span> <span class="token punctuation">(</span>singleton <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>             <span class="token keyword">synchronized</span> <span class="token punctuation">(</span>Singleton<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                 <span class="token keyword">if</span> <span class="token punctuation">(</span>singleton <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>                     singleton <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Singleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                 <span class="token punctuation">}</span>             <span class="token punctuation">}</span>         <span class="token punctuation">}</span>         <span class="token keyword">return</span> singleton<span class="token punctuation">;</span>      <span class="token punctuation">}</span>  <span class="token punctuation">}</span></code></pre><p><strong>优点：</strong>线程安全，延迟加载，效率较高</p><hr><h2 id="静态内部类（推荐）"><a href="#静态内部类（推荐）" class="headerlink" title="静态内部类（推荐）"></a>静态内部类（推荐）</h2><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Singleton</span> <span class="token punctuation">{</span>      <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">SingletonHolder</span> <span class="token punctuation">{</span>         <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> Singleton INSTANCE <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Singleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token punctuation">}</span>      <span class="token keyword">private</span> <span class="token function">Singleton</span> <span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span>      <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">final</span> Singleton <span class="token function">getInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>         <span class="token keyword">return</span> SingletonHolder<span class="token punctuation">.</span>INSTANCE<span class="token punctuation">;</span>      <span class="token punctuation">}</span>  <span class="token punctuation">}</span></code></pre><p><strong>优点：</strong>利用classloader机制来保证初始化instance时只有一个线程，Singleton类被装载时，SingletonHolder类没有被主动使用，即 Lazy Loading</p><hr><h2 id="枚举（推荐）"><a href="#枚举（推荐）" class="headerlink" title="枚举（推荐）"></a>枚举（推荐）</h2><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">enum</span> Singleton <span class="token punctuation">{</span>    INSTANCE<span class="token punctuation">;</span>      <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">whateverMethod</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token punctuation">}</span>  <span class="token punctuation">}</span></code></pre><p>优点：线程安全，防止反序列化</p>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 创建型模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>设计模式7大原则</title>
      <link href="/2020/04/30/she-ji-mo-shi-7-da-yuan-ze/"/>
      <url>/2020/04/30/she-ji-mo-shi-7-da-yuan-ze/</url>
      
        <content type="html"><![CDATA[<h1 id="设计模式7大原则"><a href="#设计模式7大原则" class="headerlink" title="设计模式7大原则"></a>设计模式7大原则</h1><h2 id="单一指责"><a href="#单一指责" class="headerlink" title="单一指责"></a>单一指责</h2><p><code>对类来说，既一个类应该只负责一项指责。如类A负责两个不同指责：指责1，指责2；当指责1需求变更而改变A时，可能造成指责2执行错误，所以需要将类A的粒度分解为A1，A2</code></p><p><code>软件设计应遵守单一职责原则，将不同的职责封装到不同的类或模块中</code></p><h2 id="开闭原则"><a href="#开闭原则" class="headerlink" title="开闭原则"></a>开闭原则</h2><p><code>开闭原则的意思是：**对扩展开放，对修改关闭**。在程序需要进行拓展的时候，不能去修改原有的代码，实现一个热插拔的效果。简言之，是为了使程序的扩展性好，易于维护和升级。想要达到这样的效果，我们需要使用接口和抽象类，后面的具体设计中我们会提到这点。</code></p><ul><li><p><code>通过扩展已有软件系统，可以提供新的行为，以满足对软件的新的需求，使变化中的软件有一定的适应性和灵活性。</code></p></li><li><p><code>已有软件模块，特别是最重要的抽象层模块不能再修改，这使变化中的软件系统有一定的稳定性和延续性` `实现开闭原则的关键在于 **分离不变和变化的部分，并对变化的部分进行合理的高层抽象，并让不变的部分依赖该高层抽象**，这样就能在不同的实现间切换，或者扩展新的实现。很多设计模式都体现了这一点，比如策略模式将算法抽象出来，模板方法将不变的算法骨架与易变的需要自定义的步骤隔离，装饰者模式将不变的核心功能对象和易变的增强功能隔离等等</code></p></li></ul><h2 id="里氏代换原则"><a href="#里氏代换原则" class="headerlink" title="里氏代换原则"></a>里氏代换原则</h2><p><code>里氏代换原则是面向对象设计的基本原则之一。 里氏代换原则中说，任何基类可以出现的地方，子类一定可以出现。LSP 是继承复用的基石，只有当派生类可以替换掉基类，且软件单位的功能不受到影响时，基类才能真正被复用，而派生类也能够在基类的基础上增加新的行为。里氏代换原则是对开闭原则的补充。实现开闭原则的关键步骤就是抽象化，而基类与子类的继承关系就是抽象化的具体实现，所以里氏代换原则是对实现抽象化的具体步骤的规范。</code></p><h2 id="依赖倒转原则"><a href="#依赖倒转原则" class="headerlink" title="依赖倒转原则"></a>依赖倒转原则</h2><p><code>这个原则是开闭原则的基础，具体内容：针对接口编程，依赖于抽象而不依赖于具体。</code></p><h2 id="接口隔离原则"><a href="#接口隔离原则" class="headerlink" title="接口隔离原则"></a>接口隔离原则</h2><p><code>这个原则的意思是：使用多个隔离的接口，比使用单个接口要好。它还有另外一个意思是：降低类之间的耦合度。由此可见，其实设计模式就是从大型软件架构出发、便于升级和维护的软件设计思想，它强调降低依赖，降低耦合。</code></p><h2 id="迪米特法则（最少知道原则）"><a href="#迪米特法则（最少知道原则）" class="headerlink" title="迪米特法则（最少知道原则）"></a>迪米特法则（最少知道原则）</h2><p><code>最少知道原则是指：一个实体应当尽量少地与其他实体之间发生相互作用，使得系统功能模块相对独立。</code></p><p><code>原则：只与直接的朋友进行通信</code></p><blockquote><p>直接的朋友：每个对象都会与其他对象有耦合关系，只要两个对象之间有耦合关系，我们就说这两个对象之间是朋友关系。耦合的方式很多，依赖，关联，组合，聚合等。其中，我们称出现<strong>成员变量，方法参数，方法返回值</strong>中的类为直接的朋友，而且现在<strong>局部变量中的类不是直接的朋友</strong>。也就是说，陌生的类最好不要以局部变量的形式出现在类的内部</p></blockquote><p>​     </p><h2 id="合称复用原则"><a href="#合称复用原则" class="headerlink" title="合称复用原则"></a>合称复用原则</h2><p><code>合成复用原则是指：尽量使用合成/聚合的方式，而不是使用继承。</code></p>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式七大原则 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>docker-simple</title>
      <link href="/2020/04/30/docker/"/>
      <url>/2020/04/30/docker/</url>
      
        <content type="html"><![CDATA[<h1 id="一、环境配置"><a href="#一、环境配置" class="headerlink" title="一、环境配置"></a>一、环境配置</h1><pre class=" language-shell"><code class="language-shell">1、检查内核版本，必须是3.10及以上 uname ‐r 2、安装docker yum install docker3、输入y确认安装4、启动docker [root@localhost ~]# systemctl start docker               [root@localhost ~]# docker ‐v                Docker version 1.12.6, build 3e8e77d/1.12.65、开机启动docker [root@localhost ~]# systemctl enable docker                  Created symlink from /etc/systemd/system/multi‐user.target.wants/docker.service to /usr/lib/systemd/system/docker.service. 6、停止docker systemctl stop docker</code></pre><p><img src="/images/docker/aliyun-docker.png" alt=""></p><h2 id="Docker常用命令-amp-操作"><a href="#Docker常用命令-amp-操作" class="headerlink" title="Docker常用命令&amp;操作"></a>Docker常用命令&amp;操作</h2><p><img src="/images/docker/simple.png" alt=""></p><h2 id="操作指令"><a href="#操作指令" class="headerlink" title="操作指令"></a>操作指令</h2><pre class=" language-shell"><code class="language-shell">1.搜索镜像 docker search tomcat 2.拉取镜像 docker pull tomcat 3.根据镜像启动容器 docker run --name mytomcat -d tomcat:latest 4.查看运行中的容器 docker ps 5.停止运行中的容器 docker stop 容器id 6.查看所有的容器 docker ps -a 7.启动容器 docker start 容器id 8.删除一个容器 docker rm 容器id 9.启动一个做了端口映射的tomcat docker run -d -p 8888:8080 tomcat 10.查看容器的日志 docker logs 容器id/容器名字 11.容器挂载 docker run --name mysql -v /conf/mysql:/etc/mysql mysql 12.进入容器 docker exec -it 容器id bash</code></pre><h2 id="迁移与备份"><a href="#迁移与备份" class="headerlink" title="迁移与备份"></a>迁移与备份</h2><pre class=" language-shell"><code class="language-shell">1.容器保存为镜像docker commit 现有容器id/容器名字 保存的镜像名字2.镜像备份docker save -o 保存的名字.tar 要保存的镜像3.镜像恢复与迁移docker load -i 要恢复的文件.tar</code></pre>]]></content>
      
      
      <categories>
          
          <category> docker </category>
          
      </categories>
      
      
        <tags>
            
            <tag> init </tag>
            
            <tag> simple syntax </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2020/04/28/hello-world/"/>
      <url>/2020/04/28/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><pre class=" language-bash"><code class="language-bash">$ hexo new <span class="token string">"My New Post"</span></code></pre><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><pre class=" language-bash"><code class="language-bash">$ hexo server</code></pre><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><pre class=" language-bash"><code class="language-bash">$ hexo generate</code></pre><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><pre class=" language-bash"><code class="language-bash">$ hexo deploy</code></pre><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> init </tag>
            
            <tag> simple syntax </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
